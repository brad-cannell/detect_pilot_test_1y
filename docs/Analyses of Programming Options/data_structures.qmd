---
title: Memory Burden of Data Structures in R and Python
date: last-modified
date-format: DD MMMM YYYY
execute:
  debug: true

toc: true
toc-depth: 4
number-sections: false
bibliography: bibliography.bib
csl: https://www.zotero.org/styles/american-medical-association-brackets

format:
  html:
    embed-resources: true
    code-tools: true
    code-annotations: hover
  pdf:
    documentclass: report

engine: knitr
editor: visual
---

# Memory Burden of Data Structures in R and Python

## Python

Python is less straightforward than R when it comes to measuring memory. There is an internal magic method, `__sizeof__()`, which measures the size of a particular object in bytes. The `sys` module function `getsizeof()` calls the `__sizeof__()` method, while adding the "garbage collector overhead" for a more complete image of memory demand. However, these only look at an individual Object - if the Object is a container, it does not follow the individual references within that container! This can lead to an underestimation of memory demand [@pypkg_sys]. Fortunately, most libraries and packages that focus on handling large data structures have their own built-in methods to assess the memory burden of their Object Types.

### Variables

Python has both Mutable and Immutable Objects. Mutable Objects allow for their values to be modified in the same area of memory space, while Immutable Objects do not [@python3ref, "Built-in Types"].

Python's variables are not Objects themselves in that they do not directly hold values. Rather, variables are pointers which direct towards a region of the memory space which holds an Object. In this way, variables function as "shortcuts" and "address books" rather than actual containers. This means variables are never bound to any single Object type [@python3ref, "Built-in Types"].

```{python}
a = 1                         # <1>
print(type(a),a)              # <2>
a = "cat"                     # <3>
print(type(a),a)              # <4>
a = [1,2,3,4]                 # <5>
print(type(a),a)              # <6>
```

1.  Variable `a` is set to point to the Integer Object that stores the value `1`

2.  `print()` displays both the `type()` of the Object that the variable `a` points to, and the value of that Object

3.  Variable `a` is set to point to the String Object that stores the value `"cat"` 4.`print()` displays both the `type()` of the Object that the variable `a` points to, and the value of that Object

4.  `print()` displays both the `type()` of the Object that the variable `a` points to, and the value of that Object

5.  Variable `a` is set to point to the List Object that stores the value `[1,2,3]`

6.  `print()` displays both the `type()` of the Object that the variable `a` points to, and the value of that Object

It might be tempting to think that `is` and `==` are synonymous, but this is not true. The logical operator `is` compares the "memory addresses" to see if the variables reference the same area of memory space. The logical operator `==`, in contrast, determines if the values referenced by the variables are equal, even if they are in a different part of memory space. This is particularly important for mutable data types, like lists [@python3ref, "Expressions"].

There is a global function `del`, which can delete a variable and the contained "memory address" within it [@python3ref, "Data Structures"]

```{python}
a = 10                        # <1>
print(a)                      # <2>
del a                         # <3>
try:                          # <4>
    print(a)                  # <4>
except Exception as e:        # <5>
    print(e)                  # <5>
```

1.  Variable `a` is set to reference the Integer Object that holds the value `10`
2.  `print()` displays the value of the Object that variable `a` points to
3.  `del` erases the "memory address" held in variable `a`
4.  We use a `try` block to `print()` to display the value of the Object that variable `a` points to
5.  If our `try` block fails due to an `Exception`, we `print()` the `Exception`; in this case, we are told that `a` is not defined because `a` does not reference anything!

When a variable is assigned to reference another variable, it "copies" the memory address of that variable. It does *not* mean that it copies the "memory address" of the other variable. Rather, it makes a copy of the address at that point in time [@python3ref, "Built-in Types"].

```{python}
a = 12                                                  # <1>
b = a                                                   # <2>
print(a==b)                                             # <3>
print(f"The memory address of 'a' is: {id(a)}")         # <4>
print(f"The memory address of 'b' is: {id(b)}")         # <4>
print(a is b)                                           # <5>
del a                                                   # <6>
try:                                                    # <7>                                              
  print (a==b)                                          # <7>
  print(f"The memory address of 'a' is: {id(a)}")       # <7>
  print(f"The memory address of 'b' is: {id(b)}")       # <7>
  print (a is b)                                        # <7>
except Exception as e:                                  # <8>
  print (e)                                             # <8>
  print(f"The memory address of 'b' is: {id(b)}")       # <8>

```

1.  Variable `a` is set to reference the Integer Object that holds the value `12`
2.  Variable `b` is set to reference the same Object memory space as variable `a`
3.  `print()` displays if `a` and `b` refer to Object(s) with the same value
4.  `print()` displays the memory address of the Objects that `a` and `b` refer to, and we can see that they are equal
5.  `print()` displays if `a` and `b` refer to the same Object in memory space
6.  `del` erases the "memory address" held in variable `a`
7.  We use a `try` block to repeat steps 3-5 after the deletion of `a` in step 5
8.  If our `try` block fails due to an `Exception`, we `print()` the `Exception` and the memory address of the variable held in `b`; in this case, we are told that `a` is not defined because `a` does not reference anything, and the memory address held in variable `b` is unchanged

##### Mutable Objects

Python's built in mutable objects include lists, dictionaries, and sets. Mutable data types allow for modification of the data in place. This is because Python's Mutable Objects actually only contain references to other Objects, not values themselves [@python3ref, "Built-in Types"].

The difference between the logical operators `is` and `==` are much clearer in Mutable Objects. This is because Python creates a new Mutable Object any time values are specified, in anticipation that their content may change [@python3ref, "Built-in Types"].

```{python}
a = [1,2,3]       # <1>
b = [1,2,3]       # <2>
print(a==b)       # <3>
print(a is b)     # <4>
```

1.  Variable `a` is set to reference a List Object, which contains ordered references to the Integer Objects which hold the values of `1`, `2`, and `3`.
2.  Variable `b` is set to reference a List Object, which contains ordered references to the Integer Objects which hold the values of `1`, `2`, and `3`.
3.  `print()` displays if `a` and `b` ultimately refer to Object(s) with the same value(s)
4.  `print()` displays if `a` and `b` refer to the same Object in memory space

Mutable objects are capable of being modified in place within the same area of reference space. However, this does depend on the method that is used to modify the mutable object [@python3ref, "Built-in Types"].

A clear example of this is lists. If you modify the list with addition, you call the `__add__` magic method, which creates a new List Object, but changes the reference of the variable to the new Object [@python3ref, "Built-in Types"].

```{python}
a = [1,2,3]                                       # <1>
b = a                                             # <2>
print(a==b)                                       # <3>
print(f"a's Original ID: {id(a)}")                # <4>
print(f"b's Original ID: {id(b)}")                # <4>
print(a is b, a, b)                               # <5>
a = a + [4]                                       # <6>
print(a==b)                                       # <7>
print(f"a's New ID: {id(a)}")                     # <7>
print(f"b's New ID: {id(b)}")                     # <7>
print(a is b, a, b)                               # <7>
```

1.  Variable `a` is set to reference a List Object, which contains ordered references to the Integer Objects which hold the values of `1`, `2`, and `3`.
2.  Variable `b` is set to reference the same Object as variable `a`.
3.  `print()` displays if `a` and `b` ultimately refer to Object(s) with the equivalent value(s)
4.  `print()` displays the memory address of the Objects that `a` and `b` refer to, and we can see that they are equal
5.  `print()` displays if `a` and `b` refer to the same Object in memory space, and the values referenced by `a` and `b`
6.  The `+` operator calls the `__add__` magic method, which creates a new List Object that contains the ordered references contained i the List Object referenced by variable `a`, adds a reference to the Integer Object that holds the value of `4`, then changes the address of the variable `a` to reference the new List Object
7.  By repeating steps 3-5, we see that the variable `b` did not change its reference, while `a` refers to the new List Object created in step 6

This is in contrast to the `append()` function built into List Objects, which modifies the list in place [@python3ref, "Built-in Types"].

```{python}
a = [1,2,3]                                       # <1>
b = a                                             # <2>
print(a==b)                                       # <3>
print(f"a's Original ID: {id(a)}")                # <4>
print(f"b's Original ID: {id(b)}")                # <4>
print(a is b, a, b)                               # <5>
a.append(4)                                       # <6>
print(a==b)                                       # <7>
print(f"a's New ID: {id(a)}")                     # <7>
print(f"b's New ID: {id(b)}")                     # <7>
print(a is b, a, b)                               # <7>
```

1.  Variable `a` is set to reference a List Object, which contains ordered references to the Integer Objects which hold the values of `1`, `2`, and `3`.
2.  Variable `b` is set to reference the same Object as variable `a`.
3.  `print()` displays if `a` and `b` ultimately refer to Object(s) with the equivalent value(s)
4.  `print()` displays the memory address of the Objects that `a` and `b` refer to, and we can see that they are equal
5.  `print()` displays if `a` and `b` refer to the same Object in memory space, and the values referenced by `a` and `b`
6.  The `append()` function modifies the List Object referenced by variable `a` by adding a reference to the Integer Object that holds the value of `4` at the end of the list.
7.  By repeating steps 3-5, we see that neither `a` nor `b` changed their reference in memory space, and continue to refer to the same List Object even though only variable `a` was updated

While this modification-in-place approach is conservative for memory, it may lead to unanticipated events if two variables are used to reference the same Mutable Object [@python3ref, "Built-in Types"].

```{python}
a = ["a","b","c","d"]
b = a
a.append("adding this to a!")
print(b)
```

##### Immutable Objects

Python's built in immutable objects are tuples, floats, integers, booleans, and strings. Immutable objects do not allow for any modification-in-place, but rather require a copy-on-modify approach [@python3ref, "Built-in Types"].

The main exceptions to this are front-loaded objects in Python, such as the integers from -5 to 256. These objects are front-loaded to account for a degree of "expected memory use" by common variables such as counters and basic mathematics, since rapidly allocating and freeing memory can reduce execution speed [@python3ref, "Built-in Types"].

```{python}
a = 256           # <1>
b = 256           # <2>
print(a==b)       # <3>
print(a is b)     # <4>
```

1.  Variable `a` is set to reference Integer Object that holds the value of `256`, which already exists due to Python's Front-Loading
2.  Variable `b` is set to reference Integer Object that holds the value of `256`, which already exists due to Python's Front-Loading
3.  `print()` displays if `a` and `b` ultimately refer to Object(s) with the same value(s)
4.  `print()` displays if `a` and `b` refer to the same Object in memory space

Outside of this front loading, each immutable object is created new in memory, even if they are equal [@python3ref, "Built-in Types"].

```{python}
a = 257           # <1>
b = 257           # <2>
print(a==b)       # <3>
print(a is b)     # <4>
```

1.  Variable `a` is set to reference Integer Object that holds the value of `257`, which is created since it was not Front-Loaded
2.  Variable `b` is set to reference Integer Object that holds the value of `256`, which is created since it was not Front-Loaded
3.  `print()` displays if `a` and `b` ultimately refer to Object(s) with the same value(s)
4.  `print()` displays if `a` and `b` refer to the same Object in memory space

Since immutable objects don't allow for any type of modification-in-place, the modification of an immutable object by necessity changes its reference in memory space [@python3ref, "Built-in Types"].

```{python}
a = 2                                             # <1>
b = a                                             # <2>
print(a==b)                                       # <3>
print(f"a's Original ID: {id(a)}")                # <4>
print(f"b's Original ID: {id(b)}")                # <4>
print(a is b, a, b)                               # <5>
a *= 18                                           # <6>
print(a==b)                                       # <7>
print(f"a's New ID: {id(a)}")                     # <7>
print(f"b's New ID: {id(b)}")                     # <7>
print(a is b, a, b)                               # <7>
```

1.  Variable `a` is set to reference the Integer Object that holds the value of `2`
2.  Variable `b` is set to reference the same Object as variable `a`.
3.  `print()` displays if `a` and `b` refer to Objects with the same value
4.  `print()` displays the memory address of the Objects that `a` and `b` refer to, and we can see that they are equal
5.  `print()` displays if `a` and `b` refer to the same Object in memory space, and the values referred to by `a` and `b`
6.  The `*=` operator makes this statement equivalent to `a = a * 18`; the `__mul__` magic method is called, which creates a new Integer Object by calculating the value returned by multiplying the value held by the Integer Object referenced by variable `a` (2x18 = 36), then changes the address of variable `a` to reference this new Integer Object
7.  By repeating steps 3-5, we see that the variable `b` did not change its reference, while `a` refers to the new Integer Object created in step 6

As such, any modification of an immutable object *by necessity* requires enough available memory to have two copies of the object at the same time, so that the variable reference can be shifted from the old object to the new object [@python3ref, "Built-in Types"].

#### Common Data Type Sizes

The most common individual Data Types in Python have known sizes [@python3ref, "Built-In Types"]. The table below specifically references the Data Types recognized by the Pandas package [@pypkg_pandas].

| Data Type       | Size (Bytes)          | Description                                   |
|------------------|------------------|------------------------------------|
| bool            | 1 bit (1/8 byte)      | True/False                                    |
| int8            | 1                     | -128 to 127                                   |
| int32           | 4                     | -32768 to 23767                               |
| int64           | 8                     | -9223372036854775808 to 9223372036854775807\* |
| uint8           | 1                     | 0 to 225                                      |
| uint32          | 4                     | 0 to 65535                                    |
| uint64          | 8                     | 0 to 18446744073709551615                     |
| float16         | 2                     | half-precision float                          |
| float32         | 4                     | single precision float                        |
| float64         | 8                     | double precision float\*                      |
| complex64       | 8                     | Complex number, two float32                   |
| complex128      | 16                    | Complex number, two float64                   |
| datetime64      | 64                    | Dates and Times                               |
| timedelta\[ns\] | 64                    | Differences of Dates and Times                |
| category        | (number categories)/8 | Categorical Data                              |

### CPython Data Structures

#### Nested Lists

Data Frames are not a part of base Python. The closest analogue to a Data Frame within base Python is a List Object that contains other List Objects (Nested Lists). However, this is neither very useful nor very intuitive. There are no item type protections or labels provided for such a List Object. Indexing generally follows a \[column\]\[row\] format, but depending on the depth of nesting may go even deeper [@python3ref, "Built-in Types"].

```{python}
import sys                                                                # <1>
a = [1,2]                                                                 # <2>
b = [3,4,5]                                                               # <3>
c = [6,7,8,9]                                                             # <4>
print(f"The size of a: {sys.getsizeof(a)}, b: {sys.getsizeof(c)}, c: {sys.getsizeof(c)}") # <5>
array = [a,b,c]                                                           # <6>
print(f"The array: {array}")                                              # <7>
print(f"The size of the array is: {sys.getsizeof(array)}, but with all elements is: {sys.getsizeof(array)+sys.getsizeof(a)+sys.getsizeof(b)+sys.getsizeof(c)}") # <8>
print(f"The first row of the array: {array[0]}")                          # <9>
print(a is array[0])                                                      # <9>                  
print(f"The first column of the second row of the array: {array[1][0]}")  # <10>
print(b[0] is array[1][0])                                                # <10>
```

1.  The `sys` module is imported to allow the use of the `getsizeof()` method to estimate memory burden [@pypkg_sys].
2.  The variable `a` is set to refer to a List Object containing ordered references to the Integer Objects that hold values of `1` and `2`
3.  The variable `b` is set to refer to a List Object containing ordered references to the Integer Objects that hold values of `3`, `4`, and `5`
4.  The variable `c` is set to refer to a List Object containing ordered references to the Integer Objects that hold values of `6`, `7`, `8` and `9`
5.  `print()` displays the memory burden (in bytes) of the objects referenced by variables `a`, `b`, and `c`.
6.  The variable of `array` is set to refer to a List Object containing ordered references to the List Objects referred to by `a`, `b`, and `c`
7.  `print()` displays the values referred to by `array`, showing the two-dimensional structure
8.  `print()` displays the memory burden (in bytes) of the object referenced by `array`, as well as the total memory burden of the items it refers to
9.  We index array, and are able to see that `array` did copy the "memory addresses" referenced by `a`
10. We index the array again, and are able to see that `array` did copy the "memory addresses" referenced by `b` at the individual level

While there is a standard library within the CPython distribution to handle arrays, it is highly specific in its uses. Even the Python documentation recommends the package *NumPy* for most uses [@python3ref "array--Efficient arrays of numeric values"].

### NumPy: Arrays, Vectors, and Matrices

*NumPy*, typically imported as `np`, specializes in scientific computing, including necessities for basic linear algebra and statistical operations. The NumPy package is what adds Arrays and Matrices to Python [@pypkg_numpy].

The basic element NumPy adds to Python is the array, which can measure its own size through the `array.itemsize` and `array.size` attributes. The `array.itemsize` attributes retrieves the size of array elements in bytes, while the `array.size` attribute returns the total number of elements in the array. By checking to see if there is any difference in memory size when generating an array by passing a variable that refers to a list compared to directly entering the list into NumPy, we can see that NumPy arrays are much more memory efficient than lists [@pypkg_numpy].

```{python}
import numpy as np                                    # <1>
a = [1,2,3,4,5,6,7,8]                                 # <2>
b = np.array(a)                                       # <3>
c = np.array([1,2,3,4,5,6,7,8])                       # <4>
print(type(a),a)                                      # <5>
print(f"The size of 'a' is: {sys.getsizeof(a)}")      # <5>
print(type(b),b)                                      # <6>
print(f"The base memory size of 'b': {b.itemsize*b.size}")  # <6>
print(type(c),c)                                      # <7>
print(f"The base memory size of 'c': {c.itemsize*c.size}")  # <7>

```

1.  The *NumPy* package is imported using the customary abbreviation of `np` for arrays [@pypkg_numpy]
2.  The variable `a` is set to refer to a List Object that contains ordered references to the Integer Objects `1`, `2`, `3`, `4`, `5`, `6`, `7`, and `8`
3.  The variable `b` is set to refer to the Array Object created by passing the List Object referred to by variable `a` through the `np.array()` method
4.  The variable `c` is set to refer to the Array Object created by passing a List Object that is equivalent to the List Object in `a` directly though the `np.array()` method
5.  `print()` displays the type and content of `a`, and its memory burden
6.  `print()` displays the type and content of `b`, and its memory burden
7.  `print()` displays the type and content of `c`, and its memory burden

While NumPy does have matrices, their matrices are planned for depreciation. NumPy's arrays can have multiple dimensions, and as such are suitable to use for matrices. Any one-dimensional array can be converted into a multidimensional array using the `array.reshape()` method, which generates a new object in memory [@pypkg_numpy].

```{python}
import numpy as np                                              # <1>
a = [1,2,3,4,5,6,7,8]                                           # <2>
print(type(a),a, id(a))                                         # <3>
print(f"The size of 'a' is: {sys.getsizeof(a)}")                # <3>
b = np.array(a)                                                 # <4>
print(type(b),b, id(b))                                         # <5>
print(f"The base memory size of 'b': {b.itemsize*b.size}")      # <5>
c = b.reshape(2,4)                                              # <6>
print(type(b),b, id(b))                                         # <7>
print(f"The base memory size of 'b': {b.itemsize*b.size}")      # <7>
print(type(c),c, id(c))                                         # <8>
print(f"The base memory size of 'c': {c.itemsize*b.size}")      # <8>
```

1.  The *NumPy* package is imported using the customary abbreviation of `np` for arrays [@pypkg_numpy]

2.  The variable `a` is set to refer to a List Object that contains ordered references to the Integer Objects `1`, `2`, `3`, `4`, `5`, `6`, `7`, and `8`

3.  `print()` displays the type, content, and "memory address" of the Object referred to by `a`

4.  The variable `b` is set to refer to the Array Object created by passing the List Object referred to by variable `a` through the `np.array()` method

5.  `print()` displays the type, content, "memory address," and memory burden of the Object referred to by `b`

6.  The variable `c` is set to refer to the Array Object created by passing the Array Object referred to by variable `b` through the `array.reshape()` method, requesting 2 rows of 4 columns filled in the default row-wise order

7.  `print()` displays the type, content, "memory address," and memory burden of the Object referred to by `b`, and we can see it has not changed

8.  `print()` displays the type, content, "memory address," and memory burden of the Object referred to by `c` - if anything, it's actually *smaller* than `b`!

NumPy is almost guaranteed to be a prerequisite for any of Python's DataFrame packages, simply due to it's power and efficiency.

### Data Frame Packages for Python

#### pandas
The most ubiquitous Data Frame package in Python is pandas [@pypkg_pandas], which directly builds from (and is dependent on) NumPy. 

Pandas can read and write in multiple file types, including CSV, JSON, HTML, Excel, SQL, and Pickle files [@pypkg_pandas]. There is a package called *pyreadr* which enables reading and writing R's Rds files [@pypkg_pyreadr].

##### Arrays (Series)
Pandas builds on the concept of arrays, provided by NumPy, with Series Objects. These Series Objects are relatively identical to NumPy arrays, but with a few modifications for flexibility: the addition of a catch-all `dtype` of object to facilitate mixed data types in a single Series, and assignment of an index value [@pypkg_pandas]. 

A Series Object can be created from any "array-like" object, including Lists, Iterables, and Dictionaries. The simplest example of this is using a List Object [@pypkg_pandas].

```{python}
import pandas as pd                         # <1>

a = [1,2,3,4,5,6,7,8]                       # <2>
series = pd.Series(a)                       # <3>
print(series)                               # <4>
b = [1,"apple",3,"book",5,False,7,8]        # <5>
series_b = pd.Series(b)                     # <6>
print(series_b)                             # <6>
```
1. The *pandas* package is imported with the customary abbreviation of `pd` [@pypkg_pandas]
2. The variable `a` is set to refer to a List Object that contains ordered references to the Integer Objects `1`, `2`, `3`, `4`, `5`, `6`, `7`, and `8`
3. The variable `series` is set to refer to a *pandas* Series Object which refers to the values referenced by variable `a`. Since an `index` is not passed, one is automatically created.
4. `print()` displays the values referenced by the Series Object referenced by `series`. The Series is assigned a `dtype` of int64 as all references in the series are to Integer Objects.
5. The variable `b` is set to refer to a List Object that contains ordered references to mixed object types that refer to the values `1`, `apple`, `3`, `book`, `5`, `False`, `7`, and `8`
6. Steps 3 and 4 are repeated to demonstrate that the Series can contain mixed object types, which causes the `dtype` to be object

NumPy arrays can be directly converted into a pandas Series Object [@pypkg_pandas].

```{python}
import numpy as np                                # <1>
import pandas as pd                               # <2>

a = np.array([1,2,3,4,5,6,7,8])                   # <3>
print(a)                                          # <4>
series = pd.Series(a)                             # <5>
print(series)                                     # <6>
```
1.  The *NumPy* package is imported using the customary abbreviation of `np` for arrays [@pypkg_numpy]
2. The *pandas* package is imported with the customary abbreviation of `pd` [@pypkg_pandas]
3. The variable `a` is set to refer to a *NumPy* Array Object that contains ordered references to the Integer Objects `1`, `2`, `3`, `4`, `5`, `6`, `7`, and `8`
4. `print()` displays the contents referenced by variable `a`
5. The variable `series` is set to refer to a *pandas* Series Object created from the NumPy Array Object referenced by variable `a`
6. `print()` displays the contents referenced by variable `series`

As we've seen, pandas Series Objects display their index. While pandas can automatically assign a simple numerical index, alternative values for the indexes can be specified. Similarly, there is also an option to give a `name` to the Series [@pypkg_pandas].

This allows for flexible indexing, similar to R [@pypkg_pandas].

```{python}
import pandas as pd                             # <1>

a = [1,2,3,4,5,6,7,8]                           # <2>
a_index = ["a","b","c","d","e","f","g","h"]     # <3>
series = pd.Series(a,index = a_index, name="Series") # <4>
print(series.iloc[2])                           # <5>
print(series["c"])                              # <6>
```
1. The *pandas* package is imported with the customary abbreviation of `pd` [@pypkg_pandas]
2. The variable `a` is set to refer to a List Object that contains ordered references to the Integer Objects `1`, `2`, `3`, `4`, `5`, `6`, `7`, and `8`
3. The variable `a_index` is set to refer to a List Object that contains ordered references to the String Objects `'a'`, `'b'`, `'c'`, `'d'`, `'e'`, `'f'`, `'g'`, and `'h'`
4. The variable `series` is set to refer to a *pandas* Series Object created from the List Object referenced by variable `a`, with index value defined by the List Object referenced by variable `a_index`
5. `print()` displays the result of taking the `iloc()` integer-based index of the Series Object `series`. Since Python indexes from 0, we would expect the 3rd value: `3`
6. `print()` displays the result of indexing the Series Object `series` by the index value `"c"`.

Since pandas objects have a built in memory-assessment method, `.memory_usage()`, we can easily do a memory comparison [@pypkg_pandas].
```{python}
import numpy as np                                              # <1>
import pandas as pd                                             # <2>

list_a = [1,2,3,4,5,6,7,8]                                      # <3>
np_array = np.array(list_a)                                     # <4>
pd_series = pd.Series(list_a)                                   # <5>

print(type(list_a),list_a)                                      # <6>
print(f"The size of 'list_a' is: {sys.getsizeof(list_a)}")      # <6>
print(type(np_array),np_array)                                  # <7>
print(f"The base memory size of 'np_array': {np_array.itemsize*np_array.size}")  # <7>
print(type(pd_series),pd_series)                                # <8>
print(f"The base memory size of 'pd_series': {pd_series.memory_usage(index=True,deep=True)}")  # <8>
```
1.  The *NumPy* package is imported using the customary abbreviation of `np` for arrays [@pypkg_numpy]
2. The *pandas* package is imported with the customary abbreviation of `pd` [@pypkg_pandas]
3. The variable `list_a` is set to refer to a List Object that contains ordered references to the Integer Objects `1`, `2`, `3`, `4`, `5`, `6`, `7`, and `8`
4. The variable `np_array` is set to refer the *NumPy* Array Object created by passing the List Object referred to by variable `list_a` through the `np.array()` method
5. The variable `pd_series` is set to refer to a *pandas* Series Object which contains the values referenced by variable `list_a`. Since an `index` is not passed, one is automatically created.
6. `print()` displays the type, content, and "memory address" of the Object referred to by `list_a`
7. `print()` displays the type, content, and "memory address" of the Object referred to by `np_array`
8. `print()` displays the type, content, and "memory address" of the Object referred to by `pd_series`

##### Data Frames

The biggest attraction to pandas is its DataFrames, which function as a list of Series Objects that share a common index. This is similar to how DataFrames are handled in R [@pypkg_pandas].

These DataFrames can be created from "array-like" objects, such as Lists, Lists, Arrays, Dictionaries, and Iterables. If the passed data have indexes, they will automatically be matched based on those values [@pypkg_pandas].

The simplest DataFrame is very similar to a Series, in which each Series "name" becomes an index to the Series. If no name is passed, columns are numbered similar to the generation of index values [@pypkg_pandas].

```{python}
import pandas as pd                                             # <1>

a = [1,2,3,4,5,6,7,8]                                           # <2>
df_a = pd.DataFrame(a)                                          # <3>
print(df_a)                                                     # <4>
b = pd.Series(a, name="a")                                      # <5>
df_b = pd.DataFrame(b)                                          # <6>
print("\n"*2, df_b)                                             # <7>
```
1. The *pandas* package is imported with the customary abbreviation of `pd` [@pypkg_pandas]
2. The variable `a` is set to refer to a List Object that contains ordered references to the Integer Objects `1`, `2`, `3`, `4`, `5`, `6`, `7`, and `8`
3. The variable `df_a` is set to refer to a *pandas* DataFrame created from the List Object referred to by variable `a`. Since there was no `name` for the series, it is automatically created
4. `print()` displays the contents of variable `df_a`
5. The variable `b` is set to refer to a *pandas* Series Object which contains the values referenced by variable `a`. Since an `index` is not passed, one is automatically created. The Series is given the `name` `"a"`.
6. The variable `df_b` is set to refer to a *pandas* DataFrame created from the Series Object referred to by variable `b`
7. `print()` displays the contents of variable `df_b`, and we can see the Series name displayed

For a more typical example would, of course, have more than a single column within the DataFrame.
```{python}
import pandas as pd                                                   # <1>

a = pd.Series([1,2,3,4,5,6,7,8], name = "numbers")                    # <2>
b = pd.Series(["a","b","c","d","e","f","g"], name = "letters")        # <3>
df = pd.DataFrame((a,b))                                              # <4>
print(df, "\n")                                                       # <5>
print(df.transpose())                                                 # <6>
```
1. The *pandas* package is imported with the customary abbreviation of `pd` [@pypkg_pandas]
2. The variable `a` is set to refer to a *pandas* Series Object with the `name` "numbers" that contains ordered references to the Integer Objects `1`, `2`, `3`, `4`, `5`, `6`, `7`, and `8`
3. The variable `b` is set to refer to a *pandas* Series Object with the `name` "letters" that contains ordered references to the String Objects `'a'`, `'b'`, `'c'`, `'d'`, `'e'`, `'f'`, and `'g'`
4. The variable `df` is set to refer to a *pandas* DataFrame created from the Series Objects referred to by variables `a` and `b`
5. `print()` displays the contents of variable `df` - we can see that each Series was placed into a row. Since `a` was longer than `b`, the last value of "letters" is `NaN`
6. `print()` displays the results of the `transpose()` method built-in to *pandas* DataFrames, which transposes columns and rows

Indexing of DataFrames is primarily "label based", in a "column first" extraction similar to R. This means that the `.iloc()` and `.loc()` methods used before (which refer to index integers and labels respectively) would return rows [@pypkg_pandas].
```{python}
import pandas as pd                                                   # <1>

a = pd.Series([1,2,3,4,5,6,7,8], name = "numbers")                    # <2>
b = pd.Series(["a","b","c","d","e","f","g"], name = "letters")        # <3>
df = pd.DataFrame((a,b))                                              # <4>
print(f"Printing the contents of the row labeled 'letters' with .loc: \n {df.loc['letters']} \n") # <5>
print(f"Printing the contents of the second row with .iloc: \n {df.iloc[1,]} \n") # <6>
print(f"Printing the contents of the column labeled `2` with [2]: \n{df[2]}")               # <7>
print(f"Printing the value of 'letters' in the column labeled `2` with [2]['letters']: \n{df[2]['letters']}") # <8>
```
1. The *pandas* package is imported with the customary abbreviation of `pd` [@pypkg_pandas]
2. The variable `a` is set to refer to a *pandas* Series Object with the `name` "numbers" that contains ordered references to the Integer Objects `1`, `2`, `3`, `4`, `5`, `6`, `7`, and `8`
3. The variable `b` is set to refer to a *pandas* Series Object with the `name` "letters" that contains ordered references to the String Objects `'a'`, `'b'`, `'c'`, `'d'`, `'e'`, `'f'`, and `'g'`
4. The variable `df` is set to refer to a *pandas* DataFrame created from the Series Objects referred to by variables `a` and `b`
5. `print()` displays the contents of the row labeled `letters`, retrieved with the `.loc[]` method
6. `print()` displays the contents of the second row, retrieved with the `.iloc[]` method
7. `print()` displays the contents of the column labeled `2`, retrieved with `[]` key-calling
7. `print()` displays the of the row labeled `letters` in the column labeled `2`, retrieved with `[]` key-calling

This is important to remember when the DataFrame is transposed - each row label now becomes a column key, and vice versa.
```{python}
import pandas as pd                                                   # <1>

a = pd.Series([1,2,3,4,5,6,7,8], name = "numbers")                    # <2>
b = pd.Series(["a","b","c","d","e","f","g"], name = "letters")        # <3>
df = pd.DataFrame((a,b))                                              # <4>
df = df.transpose()                                                   # <5>
print(f"Printing the contents of the second column with .iloc: \n {df.iloc[:,1]} \n") # <6>
print(f"Printing the contents of the column labeled 'letters' with ['letters']: \n {df['letters']} \n") # <7>
print(f"Printing the contents of the row labeled '3' with .loc: \n {df.loc[3]} \n") # <8>
print(f"Printing the value in the row labeled `3` in 'letters' with ['letters'][3]: \n {df['letters'][3]} \n") # <9>
```

1. The *pandas* package is imported with the customary abbreviation of `pd` [@pypkg_pandas]
2. The variable `a` is set to refer to a *pandas* Series Object with the `name` "numbers" that contains ordered references to the Integer Objects `1`, `2`, `3`, `4`, `5`, `6`, `7`, and `8`
3. The variable `b` is set to refer to a *pandas* Series Object with the `name` "letters" that contains ordered references to the String Objects `'a'`, `'b'`, `'c'`, `'d'`, `'e'`, `'f'`, and `'g'`
4. The variable `df` is set to refer to a *pandas* DataFrame created from the Series Objects referred to by variables `a` and `b`
5. The variable `df` is set to refer to the result of the `.transpose()` built-in method called on its existing reference
6. `print()` displays the contents of the second column, retrieved with the `.iloc[]` method
7. `print()` displays the contents of the column labeled `letters`, retrieved with `[]` key-calling
8. `print()` displays the contents of the row labeled `3`, retrieved with the `.loc[]` method
9. `print()` displays the contents of the row labeled `3` in the column labeled `letters`, retrieve with `[]` key-calling

In comparison to NumPy's 2 dimensional arrays, NumPy is much more memory efficient for initial storage when all data is of a single type. When data must be of mixed types, the pandas DataFrame is the standard format in Python. Even when data is not of mixed types, we do not need to rely on indexing for a pandas DataFrame - by utilizing key-calling methods of labels, we can bypass any need for iteration or numeric indexing in order to take subsets. Additionally, the fact that each column in a pandas DataFrame is treated as an isolated (but key-connected) Series provides similar memory-efficiency for modification operations to R's DataFrames [@pypkg_pandas].

```{python}
import numpy as np                                              # <1>
import pandas as pd                                             # <2>

a = [1,2,3,4,5,6,7,8]                                           # <3>
b = np.array(a)                                                 # <4>
c = b.reshape(2,4)                                              # <5>
df = pd.DataFrame(c)                                            # <6>
print(type(c),c, id(c))                                         # <7>
print(f"The base memory size of 'c': {c.itemsize*b.size}")      # <7>
print(type(df),df, id(df))                                      # <8>
print(f"The base memory size of 'df': {df.memory_usage(index=True,deep=True).sum()}") # <8>
```
1. The *NumPy* package is imported using the customary abbreviation of `np` for arrays [@pypkg_numpy]
2. The *pandas* package is imported with the customary abbreviation of `pd` [@pypkg_pandas]
3. The variable `a` is set to refer to a List Object that contains ordered references to the Integer Objects `1`, `2`, `3`, `4`, `5`, `6`, `7`, and `8`
4. The variable `b` is set to refer to the *NumPy* Array Object created by passing the List Object referred to by variable `a` through the `np.array()` method
5.  The variable `c` is set to refer to the *NumPy* Array Object created by passing the Array Object referred to by variable `b` through the `array.reshape()` method, requesting 2 rows of 4 columns filled in the default row-wise order
6. The variable `df` is set to refer to the *pandas* DataFrame Object created from the Array Object referred to by variable `c`
7.  `print()` displays the type, content, "memory address," and memory burden of the Object referred to by `c`
8.  `print()` displays the type, content, "memory address," and memory burden of the Object referred to by `df`

###### Data Types
There are several potential data types in pandas, which impact the memory usage of any DataFrame. In its default, pandas does attempt to minimize the memory impact of any files it reads into a DataFrame object. These object types can also be specified in the creation of the DataFrame, or modified as needed [@pypkg_pandas]. 

The most common Data Types in Pandas [@pypkg_pandas]:

| Data Type     | Size (Bytes)             | Description                                   |
|---------------|--------------------------|-----------------------------------------------|
| bool          | 1 bit (1/8 byte)         | True/False                                    |
| int8          | 1                        | -128 to 127                                   |
| int32         | 4                        | -32768 to 23767                               |
| int64         | 8                        | -9223372036854775808 to 9223372036854775807*  |
| uint8         | 1                        | 0 to 225                                      |
| uint32        | 4                        | 0 to 65535                                    |
| uint64        | 8                        | 0 to 18446744073709551615                     |
| float16       | 2                        | half-precision float                          |
| float32       | 4                        | single precision float                        |
| float64       | 8                        | double precision float*                       |
| complex64     | 8                        | Complex number, two float32                   |
| complex128    | 16                       | Complex number, two float64                   |
| datetime64    | 64                       | Dates and Times                               |
| timedelta[ns] | 64                       | Differences of Dates and Times                |
| category      | (number of categories)/8 | Categorical Data                              |


#### Polars

#### Modin

#### Dask

#### Vaex

## Summary Comparison

### List of Integers (1D)
For this comparison, we have used a list containing the Integers from 1-8, inclusive: `a=[1,2,3,4,5,6,7,8]`

|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|---|---|---|---|---|---|---|---|---|
| a | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |


| Structure        | Memory Burden (Bytes) |
|------------------|-----------------------|
| List             | 120                   |
| NumPy Array      | 32                    |
| pandas Series    | 192                   |
| pandas DataFrame | 192                   |


### DataFrames (2D)
For this comparison, we have used the following 2-dimensional structure: `a=[[1,2,3,4],[5,6,7,8]]`

|   | 0 | 1 | 2 | 3 |
|---|---|---|---|---|
| 0 | 1 | 2 | 3 | 4 |
| 1 | 5 | 6 | 7 | 8 |


| Structure            | Memory Burden (Bytes) |
|----------------------|-----------------------|
| Nested Lists         | 72                    |
| NumPy Array "Matrix" | 32                    |
| Pandas DataFrame     | 192                   |



```{python}
import sys
import numpy as np
import pandas as pd

a = [[1,2,3,4],[5,6,7,8]]
print(f"The size of a: {sys.getsizeof(a)}")
print(a)
b = np.array(a)
print(f"The base memory size of 'b': {b.itemsize*b.size}")
print(b)
c = pd.DataFrame(a)
print(f"The base memory size of 'c': {c.memory_usage(index=True,deep=True).sum()}")
print(c)

```

## R

R has the `lobstr` package, which assists in measuring memory burden through the `obj_size()` method [@rpkg_lobstr].

### Vectors

R's variables, like Python, act as references to areas of "memory space" rather than directly storing information themselves. R's variables are called vectors. Each vector is created in a new location of Memory Space, even if the contents are identical.

```{r}
library(lobstr)                                                 # <1>
a <- 1                                                          # <2>
b <- 1                                                          # <3>
print(identical(a,b))                                           # <4>
print(identical(obj_addr(a),obj_addr(b)))                       # <5>
print(obj_size(a))                                              # <6>
print(obj_size(b))                                              # <6>
```

1.  The `lobstr` package is imported to allow retrieval of object locations in memory space using the method `obj_addr()`, as well as object sizes in memory space with `obj_size()` [@rpkg_lobstr]
2.  Variable `a` is set to reference a Vector Object, which references the Numeric Double Object that holds the value of `1`
3.  Variable `b` is set to reference a Vector Object, which references the Numeric Double Object that holds the value of `1`
4.  `print()` displays the results of `identical()`, which determines if if `a` and `b` reference Objects with identical contents
5.  `print()` displays the results of `identical()`, which determines if the values returned by `obj_addr()` for `a` and `b` are identical
6.  `print()` displays the results of `obj_size()`, which returns the memory size of the referenced object

Similar to Python, variables can reference other variables by copying the "memory address" referenced at that point in time.

```{r}
library(lobstr)                                                 # <1>
a <- c(1,2,3)                                                   # <2>
b <- a                                                          # <3>
print(identical(a,b))                                           # <4>
print(identical(obj_addr(a),obj_addr(b)))                       # <5>
print(obj_size(a))                                              # <6>
print(obj_size(b))                                              # <6>
```

1.  The `lobstr` package is imported to allow retrieval of object locations in memory space using the method `obj_addr()`, as well as object sizes in memory space with `obj_size()` [@rpkg_lobstr]
2.  Variable `a` is set to reference a Vector Object, which contains ordered references to the Numeric Double Objects that hold the values of `1`,`2`, and `3`
3.  Variable `b` is set to reference the same Object as variable `a`
4.  `print()` displays the results of `identical()`, which determines if if `a` and `b` reference Object(s) with identical contents
5.  `print()` displays the results of `identical()`, which determines if the values returned by `obj_addr()` for `a` and `b` are identical
6.  `print()` displays the results of `obj_size()`, which returns the memory size of the referenced object

R's vectors are almost exclusively immutable objects. This means that R uses a behind-the-scenes copy-in-place when modifying objects.

```{r}
library(lobstr)                                                 # <1>
a <- c(1,2,3)                                                   # <2>
b <- a                                                          # <3>
print(a)                                                        # <4>
print(b)                                                        # <4>
print(identical(a,b))                                           # <5>
print(identical(obj_addr(a),obj_addr(b)))                       # <6>
a <- append(a, 4)                                               # <7>
print(a)                                                        # <8>
print(b)                                                        # <8>
print(identical(a,b))                                           # <8>
print(identical(obj_addr(a),obj_addr(b)))                       # <8>
print(obj_size(a))                                              # <9>
print(obj_size(b))                                              # <9>

```

1.  The `lobstr` package is imported to allow retrieval of object locations in memory space using the method `obj_addr()`, as well as object sizes in memory space with `obj_size()` [@rpkg_lobstr]
2.  Variable `a` is set to reference a Vector Object, which contains ordered references to the Numeric Double Objects that hold the values of `1`,`2`, and `3`
3.  Variable `b` is set to reference the same Object as variable `a`
4.  `print()` displays the Integer Objects referenced by variables `a` and `b`
5.  `print()` displays the results of `identical()`, which determines if if `a` and `b` reference Object(s) with identical contents
6.  `print()` displays the results of `identical()`, which determines if the values returned by `obj_addr()` for `a` and `b` are identical
7.  `append()` is called, which creates a new Vector Object that contains the ordered references contained in the vector referenced by variable `a`, adds an additional reference to the Numeric Double Object that holds the value of `4`, and updates the variable `a` to reference the new Vector Object
8.  By repeating Steps 4-6, we can see that the variable `b` does not change its reference, while `a` refers to the Vector Object created in Step 7.
9.  `print()` displays the results of `obj_size()`, which returns the memory size of the referenced object; we see that both `a` and `b` reference List Objects of the same size, despite `a` having additional contents than `b`, due to the rounding-up of memory.

While this means that you don't have to worry about mutable data types like you do in Python, it also means that memory demands may increase more dramatically. Even when vectors are "modified," R typically uses a copy-on-update system behind the scenes. It does attempt to perform a modify-in-place modification whenever it can, but it can be difficult to predict if copy-on-update or modify-in-place will occur [@advr2, "Vectors"].

Unlike Python, R does not actually have any 0-dimensional scalars; rather, these objects are stored in one-dimensional vectors with a length of 1 [@advr2, "Vectors"].

```{r}
a <- 5                # <1>
print(typeof(a))      # <2>
print(class(a))       # <3>
print(is.vector(a))   # <4>
```

1.  Variable `a` is set to reference the Integer Object that holds the value of `5`
2.  `print()` displays the `typeof()` the object referenced by variable `a`: "double"
3.  `print()` displays the `class()` of the object referenced by variable `a`: "numeric"
4.  `print()` displays the results of `is.vector()`, which determines if the object referenced by variable `a` is a vector

### Matrices

The foundation of Data Frames in R is matrices. A matrix is a 2-dimensional data structure, which in R, must only hold data of a single type. We can take an atomic vector and convert it into a matrix structure by specifying the number of columns and rows [@r_manual, "Matrices"].

```{r}
library(lobstr)                     # <1>
a_vector <- c(1,2,3,4,5,6,7,8)      # <2>
a_matrix <- matrix(a_vector,2,4)    # <3>
print(a_matrix)                     # <4>
print(obj_size(a_vector))           # <5>
print(obj_size(a_matrix))           # <5>
```

1.  The `lobstr` package is imported to allow retrieval of object locations in memory space using the method `obj_addr()`, as well as object sizes in memory space with `obj_size()` [@rpkg_lobstr]
2.  The variable `a_vector` is set to reference a Vector Object that holds ordered references to the Numeric Double Objects `1`,`2`,`3`,`4`,`5`,`6`,`7`, and `8`
3.  The variable `a_matrix` is set to reference the Vector Object returned by `matrix()`, which converts the Vector Object referenced by `a_vector` into a Vector Object of 2 rows and 4 columns; references are ordered "column wise" by default
4.  `print()` displays the Vector Object referenced by `a_matrix`
5.  `print()` displays the results of `obj_size()`, which returns the memory size of the referenced object; we see that `a_matrix` requires more memory than `a_vector`, due to the additional information required to store its structure.

### Data Frames

Data Frames are the integral, core data structure of R. Data Frames are matrix-like structures formed from a list of vectors, all of which share the same length. Each of these vectors represents a single variable within the Data Frame. While each vector should hold items of the same type (i.e. atomic vectors), no two vectors have to share the same data type [@r_manual, "Data Frames"].

```{r}
a_vector <- c(1,2,3,4,5,6,7,8)            # <1>
a_dataframe <- data.frame(a_vector)       # <2>
print(a_dataframe)                        # <3>
```

1.  The variable `a_vector` is set to reference a Vector Object that holds ordered references to the Numeric Double Objects `1`,`2`,`3`,`4`,`5`,`6`,`7`, and `8`
2.  The variable `a_dataframe` is set to reference the DataFrame Object returned by `data.frame()`, which converts the Vector Object referenced by `a_vector` into a DataFrame Object, which contains a copy of the references held by the Vector Object referenced by `a_vecor` as its column
3.  `print()` displays the DataFrame Object referenced by `a_dataframe`

Data Frames contain "metadata," such as column names, data types within columns, and row names. This can permit useful indexing, but can also increase the memory burden of a Data Frame. Matrices in general are more memory efficient for storage than Data Frames, as they are a single Vector Object that lacks this amount of "metadata" overhead [@r_manual, "Matrices"].

Because Data Frames are lists of vectors, with each vector being a single column, there are significant impacts of R's copy-on-modify behavior. If a column is modified, only that column has to be modified (through copy-on-modify). If a row is modified, *every* column of the data frame has to be modified (through copy-on-modify) [@advr2, "Names and Values"].

### Tibbles

*Tibbles* are the primary alternative to Data Frames in R, available as part of the `tidyverse`. Tibbles are simultaneously more relaxed than the base Data Frames, and more opinionated. Since Tibbles share much of the same structure as Data Frames, they operate under the same memory considerations [@rpkg_tibble].

```{r}
library(tibble)                           # <1>
a_vector <- c(1,2,3,4,5,6,7,8)            # <2>
a_tibble <- tibble(a_vector)              # <3>
print(a_tibble)                           # <4>
```

1.  The `tibble` library is used to provide tibble functionality [@rpkg_tibble]
2.  The variable `a_vector` is set to reference a Vector Object that holds ordered references to the Numeric Double Objects `1`,`2`,`3`,`4`,`5`,`6`,`7`, and `8`
3.  The variable `a_tibble` is set to reference the Tibble Object returned by `tibble()`, which converts the Vector Object referenced by `a_vector` into a Tibble Object, which contains a copy of the references held by the Vector Object referenced by `a_vecor` as its column
4.  `print()` displays the Tibble Object referenced by `a_tibble`

While Tibbles may have some "tidy" modifications from Data Frames, they can also increase memory burden. Tibbles don't make any of the same attempts to optimize memory storage as Data Frames, such as converting Strings into Factors. They also always subset into Tibbles, in contrast to Data Frames which can subset into the highly efficient Vectors. They also don't support arithmetic operations on all columns, instead relying on conversion to a Data Frame. So while Tibbles are "tidy" for printing and examining data without modification, Tibbles are not optimized for memory in modification [@rpkg_tibble].

### Summary Comparison

Overall, we can compare the three major data types involved in Data Frame and Data Frame-adjacent structures in R:

```{r}
library(lobstr)                           # <1>
library(tibble)                           # <2>
a_vector <- c(1,2,3,4,5,6,7,8)            # <3>
a_matrix <- matrix(a_vector,2,4)          # <4>
a_dataframe <- data.frame(a_vector)       # <5>
a_tibble <- tibble(a_vector)              # <6>
print(obj_size(a_vector))                 # <7>
print(obj_size(a_matrix))                 # <7>
print(obj_size(a_dataframe))              # <7>
print(obj_size(a_tibble))                 # <7>

```

1.  The `lobstr` package is imported to allow retrieval of object locations in memory space using the method `obj_addr()`, as well as object sizes in memory space with `obj_size()` [@rpkg_lobstr]
2.  The `tibble` library is used to provide tibble functionality [@rpkg_tibble]
3.  The variable `a_vector` is set to reference a Vector Object that holds ordered references to the Numeric Double Objects `1`,`2`,`3`,`4`,`5`,`6`,`7`, and `8`
4.  The variable `a_matrix` is set to reference the Vector Object returned by `matrix()`, which converts the Vector Object referenced by `a_vector` into a Vector Object of 2 rows and 4 columns; references are ordered "column wise" by default
5.  The variable `a_dataframe` is set to reference the DataFrame Object returned by `data.frame()`, which converts the Vector Object referenced by `a_vector` into a DataFrame Object, which contains a copy of the references held by the Vector Object referenced by `a_vecor` as its column
6.  The variable `a_tibble` is set to reference the Tibble Object returned by `tibble()`, which converts the Vector Object referenced by `a_vector` into a Tibble Object, which contains a copy of the references held by the Vector Object referenced by `a_vecor` as its column
7.  `print()` displays the results of `obj_size()`, which returns the memory size of the referenced object

Even though these objects were created referencing the same data, we can see that the increasing memory demand with increasing object complexity and "metadata" overhead: Vectors \< Matrices \< Data Frames \< Tibbles
