---
title: "Manage Variables in APS Data"
date: "Created: 2019-01-25 <br> Updated: `r Sys.Date()`"
---

# ‚≠êÔ∏èOverview

* The raw APS data was imported in data_aps_01_import.Rmd

* In this file we do some basic data cleaning and prepare the data to be merged with MedStar data.


# üì¶Load packages

```{r message=FALSE}
library(dplyr)
library(purrr)
library(fastDummies)
library(stringr)
library(lubridate)
library(tidyverse)
```


# üåêConnect to server

Connect to the UTHealth server.

```{bash eval=FALSE}
# For Brad
# open 'smb://islgpcifs.uthouston.edu/sph_research/DETECT/one_year_data/'
```


# üì•Read-in data

* aps_01_import.rds was created in data_aps_01_import.Rmd

```{r}
# aps <- readr::read_rds("/Volumes/one_year_data/aps_01_import.rds")

# For Steph
aps <- readr::read_rds("/Users/chiufengyap/OneDrive - The University of Texas Health Science Center at Houston/Research/MedStar_APS/delete/aps_01_import.rds")
```

```{r}
dim(aps) # 18,080 observations and 47 variables
```


# Standardize character strings

Because we will merge this data with other data sets in the future based on character strings (e.g., name), we need to go ahead and standardize their formats here. This will prevent mismatches during the merges. Specifically, we:

1. Transform all characters to lower case   
2. Remove trailing spaces (e.g., "John Smith ")   
3. Remove double spaces (e.g., "John  Smith")

```{r}
# Change all date of birth (dob)'s year element from "20__" to "19__" because records with similar case_num that have all dob_all_match = TRUE could have all their dob like 2027-01-01, which is impossible at this moment.

aps <- aps %>% 
  mutate(
    dob_year = format(dob, "%Y"),
    dob_month= format(dob, "%m"),
    dob_day = format(dob, "%d"),
    dob_year_1 = as.numeric(substr(dob_year,1,2)),# 2,689 rows with birth year ranges 2010 - 2029, nothing between 2000-2009
    dob_year_1 = ifelse(dob_year_1>=20, 19, dob_year_1), 
    dob_year_2 = as.numeric(substr(dob_year,3,4)),
    dob_year = paste(c(dob_year_1), c(dob_year_2), sep=""),
    dob = paste(c(dob_year), c(dob_month), c(dob_day), sep="-"),
    dob = as.Date(dob, format="%Y-%m-%d"))

aps <- subset(aps, select = -c(dob_year, dob_month, dob_day, dob_year_1, 
                               dob_year_2))
```

```{r}
aps <- aps %>% 
  mutate(
    across(
      .cols = where(is.character), 
      function(x) {
        x <- str_to_lower(x) # Make lowercase
        x <- str_trim(x) # Remove leading and trailing spaces
        x <- str_replace_all(x, "[[:blank:]]{2,}", " ") # Remove double spaces
      }
    )
  )
```

4. Remove any special characters (e.g., hyphens, periods)   

```{r}
aps <- aps %>% 
  mutate(
    across(
      c(name_last, name_first, name_full),
      ~ str_replace_all(.x, "[^a-zA-Z\\d\\s]", " ")
    )
  )
```

```{r}
dim(aps) # 18,080 observations and 47 variables
```


# Clean city

View current values for city

```{r eval=FALSE}
aps %>%
  freqtables::freq_table(city)
```

Need to move city value to street. Need to do so without using identifiers in the code. Therefore, adding a temporary row variable.

```{r}
aps <- aps %>% 
  mutate(row = row_number()) %>% 
  select(row, everything())
```

```{r}
aps <- aps %>% 
  mutate(
    street = if_else(row == 9868, city, street),
    city = if_else(row == 9868, NA_character_, city)
  )
```

Correct misspellings

```{r}
aps <- aps %>% 
  mutate(
    city = case_when(
      city == "cleburn" ~ "cleburne",
      city == "dalworthington garde" ~ "dalworthington garden",
      city == "ft worth" ~ "fort worth",
      city == "n richland hills" ~ "north richland hills",
      city == "unknown" ~ NA_character_,
      city == "wht settlemt" ~ "white settlement",
      TRUE ~ city
    )
  )
```

Drop row

```{r}
aps <- select(aps, -row)
```

```{r}
dim(aps) # 18,080 observations and 47 variables
```


# Resolve within-case discrepancies between rows

Which variables have differing values within case number? Each case number should be about the investigation of a single person. Therefore, most of the values for each variable within case should be constant. Unfortunately, this isn't the case. 

**Some notes from APS about administrative variables:**

* Each unique **Intake Stage #** (Column M) may be thought of as a unique report of ANE made on a particular date at a particular time. Each unique intake will generate a unique investigation, designated by an **Investigation Stage #** (Column L). So, each unique intake # is paired with an investigation #. With this a case is opened, assigned a **case #** (Column K)

* **Each row of data in this file may be best understood as a unique "reporter" which is the person making a report of abuse, neglect or exploitation (ANE) about a particular victim, on a particular date and time.** The name and DOB and address information in the first several columns are that of the victim, not the reporter. The only information provided about the reporter is column O, reporter type. 

* As already noted, each unique **Intake #** may be thought of as a unique report of ANE. However, there may be two reporters on the same intake, which appears as two rows with the same intake number. This reflects that two different people made the report at the same time, most likely in the way that one person speaks to the intake worker, then hands the phone to the other reporter. You may see a different reporter type in each row which is common when the victim is calling with a family member. Also common is the victim or a family member calling along with someone providing services or other assistance, maybe a health care provider, a community organization, or a law enforcement officer. They are making the call together, hence together they are making the report of ANE. Two people, one report. 

* In contrast to the above, you may see two rows with the same case number but different intake numbers which are on the same date. This represents two different reports called in independently by two different people. Thus, they have different intake numbers, and they are regarded as two different reports of the same abuse. And again, as mentioned above, they have the same case numbers because it was determined that after the initial report was made, the subsequent report concerned the same mistreatment or self-neglect and therefore was merged into the already-created case.

* For the ITS analysis, we are interested in changes in the number of individual "reports" of EA. So, each row should be a unique reporter/intake stage number combination.

* For the merge with the MedStar data, it's easiest if each case is collapsed into a single row. 

* Therefore, we after fixing discrepancies, we will create a long version and wide version of the APS data.


## Create case_row

To count the number of rows per case

```{r}
aps <- aps %>% 
  arrange(case_num) %>% 
  group_by(case_num) %>% 
  mutate(case_row = row_number()) %>% 
  ungroup() %>% 
  select(case_num, case_row, everything())
```

```{r}
dim(aps) # 18,080    48
```


## Descriptives

```{r}
aps %>% 
  summarise(
    Rows           = nrow(aps),
    `Unique cases` = length(unique(aps$case_num)),
    Difference     = Rows - `Unique cases`,
    `Min rows`     = min(case_row),
    `Max rows`     = max(case_row),
    .groups        = "drop"
  )
```

So, there are **18,080** total rows in the APS data. Of those, **15,280** represent unique cases (i.e., investigations). They do NOT represent unique people. We will identify unique people later. Most cases only have one row (i.e., one reporter); however, some cases have as many as 12 rows (i.e., 12 unique reporters, which is the person making a report of abuse, neglect or exploitation (ANE), about a particular victim, on a particular date and time).

The APS long data should have 18,080 rows. The APS wide data should have 15,280 rows.

## Check for discrepencies

### Helper function: all_match

```{r}
all_match <- function(x) {
  # If there are any NA's, check for all NA's
  if (any(is.na(x))) {
    # Check for all NA
    out <- all(is.na(x))
  } else {
    out <- length(unique(x)) == 1
  }
  out
}
```

```{r}
# It doesn't make sense to check columns that are different by design
inspect_cols <- aps %>% 
  select(
    -case_num, -case_row, -investigation_stage_num, -intake_stage_num, 
    -intake_date, -reporter, -investigation_closure_date, -closure_reason
  ) %>% 
  names()
```

```{r}
# Set column order ahead of time. This assumes that you know the names of each 
# of the columns you want to inspect
col_order <- map(
  names(aps), 
  function(x) {
    if (x %in% inspect_cols) {
      c(x, paste0(x, "_all_match"))
    } else {
      x
    }
  }
) %>% 
  unlist()
```

```{r}
inspect_aps <- aps %>% 
  group_by(case_num) %>% 
  mutate(
    across(
      .cols  = all_of(inspect_cols),
      .fns   = ~ all_match(.x),
      .names = "{col}_all_match"
    )
  ) %>% 
  dplyr::select(all_of(col_order)) %>% 
  ungroup()
```

Which columns have any discrepancies?

```{r}
inspect_aps %>% 
  select(ends_with("all_match")) %>% 
  select(where(~ !all(.x))) %>% 
  names()
```

Every column has at least one discrepancy. Let's view the discrepancies.

```{r}
all_match_cols <- select(inspect_aps, ends_with("all_match")) %>% 
  names() %>% 
  rlang::syms()
```

```{r}
walk(
  .x = all_match_cols,
  .f = function(x) {
    # Get column name w/o "all_matches" suffix
    no_suf <- str_remove(quo_name(x), "_all_match$")
    no_suf <- rlang::sym(no_suf)
    
    # Create name for new data frame
    df_nm <- str_replace(quo_name(x), "_all_match$", "")
    df_nm <- paste0("discrepancies_", df_nm)
    
    # Get the discrepancies
    results <- inspect_aps %>% 
      filter(!!x == FALSE) %>% 
      select(case_num, case_row, !!no_suf, !!x, everything())
    
    # Save to global environment
    assign(df_nm, results, envir = .GlobalEnv)
  }  
)
```


### Mode function

```{r}
Mode <- function(x) {
   ux <- unique(x)
   ux[which.max(tabulate(match(x, ux)))]
}
```


### Creating new data frame to retain the existing information in aps.

```{r}
aps_2 <- aps
```


### Discrepancies in last name

Fixing rules -
1. Go with the most common name by case_num using Mode()
2. if there are only 2 instances or if there are even instances go with the first one
3. if last name and first name seem interchanged, replace the terms accordingly

```{r}
# Creating new data frame for ease of writing code in next step
dnl <- discrepancies_name_last

aps_2 <- aps_2 %>% 
  mutate(name_last = case_when(
    case_num == 43630694 ~ dnl$name_last[dnl$case_num == 43630694 
                                         & dnl$case_row == 2],
    case_num == 43712349 ~ dnl$name_last[dnl$case_num == 43712349 
                                         & dnl$case_row == 2],
    case_num == 43834412 ~ dnl$name_last[dnl$case_num == 43834412 
                                         & dnl$case_row == 1],
    case_num == 44047558 ~ dnl$name_last[dnl$case_num == 44047558 
                                         & dnl$case_row == 2],
    case_num == 44098590 ~ dnl$name_last[dnl$case_num == 44098590 
                                         & dnl$case_row == 1],
    case_num == 44202718 ~ dnl$name_last[dnl$case_num == 44202718 
                                         & dnl$case_row == 1],
    case_num == 44361687 ~ dnl$name_last[dnl$case_num == 44361687 
                                         & dnl$case_row == 2],
    case_num == 44534324 ~ dnl$name_last[dnl$case_num == 44534324 
                                         & dnl$case_row == 4],
    case_num == 44985172 ~ dnl$name_last[dnl$case_num == 44985172 
                                         & dnl$case_row == 3],
    case_num == 45009395 ~ dnl$name_last[dnl$case_num == 45009395 
                                         & dnl$case_row == 2],
    case_num == 45241463 ~ dnl$name_last[dnl$case_num == 45241463 
                                         & dnl$case_row == 1], 
    case_num == 45561218 ~ dnl$name_last[dnl$case_num == 45561218 
                                         & dnl$case_row == 2],
    case_num == 45686452 ~ dnl$name_last[dnl$case_num == 45686452 
                                         & dnl$case_row == 1],
    case_num == 45766192 ~ dnl$name_last[dnl$case_num == 45766192 
                                         & dnl$case_row == 2],
    TRUE ~ name_last
    )
  )

# Testing to check if there are any discrepancies that are not fixed
# aps_2 %>%
#   group_by(case_num) %>%
#   mutate(test_name_last = all_match(name_last)) %>%
#   filter(test_name_last == FALSE)


# Fixing pending discrepancies       
# There is one case number (46198930) which will be split into two cases with the following case_numbers -->  90000001, 90000002

aps_2 <- aps_2 %>%
  mutate(
    case_num = case_when(
      case_num == 46198930 & case_row == 1 ~ 90000001,
      case_num == 46198930 & case_row == 2 ~ 90000002,
      TRUE ~ case_num),
    case_row = case_when(
      case_num == 90000002 ~ as.integer(1),
      TRUE ~ case_row
    )
    )
```


### Discrepancies in first_name 

```{r}
# Creating new data frame for ease of writing code in next step
dnf <- discrepancies_name_first

aps_2 <- aps_2 %>%
  mutate(name_first = case_when(
    case_num == 43630694 ~ dnf$name_first[dnf$case_num == 43630694 
                                          & dnf$case_row == 2],
    case_num == 43712349 ~ dnf$name_first[dnf$case_num == 43712349 
                                          & dnf$case_row == 2],
    case_num == 43834412 ~ dnf$name_first[dnf$case_num == 43834412
                                          & dnf$case_row == 1],
    case_num == 43933221 ~ dnf$name_first[dnf$case_num == 43933221 
                                          & dnf$case_row == 1],
    case_num == 43998424 ~ dnf$name_first[dnf$case_num == 43998424 
                                          & dnf$case_row == 1],
    case_num == 44098590 ~ dnf$name_first[dnf$case_num == 44098590 
                                          & dnf$case_row == 2],
    case_num == 44133841 ~ dnf$name_first[dnf$case_num == 44133841 
                                          & dnf$case_row == 1],
    case_num == 44149921 ~ dnf$name_first[dnf$case_num == 44149921 
                                          & dnf$case_row == 1],
    case_num == 44202718 ~ dnf$name_first[dnf$case_num == 44202718 
                                          & dnf$case_row == 1],
    case_num == 44278970 ~ dnf$name_first[dnf$case_num == 44278970 
                                          & dnf$case_row == 1],
    case_num == 44619484 ~ dnf$name_first[dnf$case_num == 44619484 
                                          & dnf$case_row == 1],
    case_num == 44759165 ~ dnf$name_first[dnf$case_num == 44759165 
                                          & dnf$case_row == 2],
    case_num == 44767336 ~ dnf$name_first[dnf$case_num == 44767336 
                                          & dnf$case_row == 2],
    case_num == 44985172 ~ dnf$name_first[dnf$case_num == 44985172 
                                          & dnf$case_row == 3],
    case_num == 45009395 ~ dnf$name_first[dnf$case_num == 45009395 
                                          & dnf$case_row == 2],
    case_num == 45086686 ~ dnf$name_first[dnf$case_num == 45086686 
                                          & dnf$case_row == 1],
    case_num == 45092611 ~ dnf$name_first[dnf$case_num == 45092611 
                                          & dnf$case_row == 1],
    case_num == 45118774 ~ dnf$name_first[dnf$case_num == 45118774 
                                          & dnf$case_row == 1],
    case_num == 45130361 ~ dnf$name_first[dnf$case_num == 45130361 
                                          & dnf$case_row == 4],
    case_num == 45342291 ~ dnf$name_first[dnf$case_num == 45342291 
                                          & dnf$case_row == 2],
    case_num == 45359082 ~ dnf$name_first[dnf$case_num == 45359082 
                                          & dnf$case_row == 1],
    case_num == 45369750 ~ dnf$name_first[dnf$case_num == 45369750 
                                          & dnf$case_row == 2],
    case_num == 45396401 ~ dnf$name_first[dnf$case_num == 45396401 
                                          & dnf$case_row == 1],
    case_num == 45405950 ~ dnf$name_first[dnf$case_num == 45405950 
                                          & dnf$case_row == 3],
    case_num == 45410028 ~ dnf$name_first[dnf$case_num == 45410028 
                                          & dnf$case_row == 2],
    case_num == 45453113 ~ dnf$name_first[dnf$case_num == 45453113 
                                          & dnf$case_row == 1],
    case_num == 45467549 ~ dnf$name_first[dnf$case_num == 45467549 
                                          & dnf$case_row == 1],
    case_num == 45475078 ~ dnf$name_first[dnf$case_num == 45475078 
                                          & dnf$case_row == 2],
    case_num == 45547900 ~ dnf$name_first[dnf$case_num == 45547900 
                                          & dnf$case_row == 1],
    case_num == 45614971 ~ dnf$name_first[dnf$case_num == 45614971 
                                          & dnf$case_row == 2],
    case_num == 45686452 ~ dnf$name_first[dnf$case_num == 45686452 
                                          & dnf$case_row == 1],
    case_num == 46169389 ~ dnf$name_first[dnf$case_num == 46169389 
                                          & dnf$case_row == 1],
    case_num == 46232228 ~ dnf$name_first[dnf$case_num == 46232228 
                                          & dnf$case_row == 3],
    TRUE ~ name_first
                        
        ))

# Testing if there are any discrepancies that were not fixed
# aps_2 %>%
#   group_by(case_num) %>%
#   mutate(test_name_first = all_match(name_first)) %>%
#   filter(test_name_first == FALSE)

# Issues with 2 case numbers - 43634107, 45202615
# Based on Dr. Cannell's suggestion going to split these into 4 different cases: 90000003, 90000004, 90000005, 90000006

aps_2 <- aps_2 %>%
  mutate(case_num = case_when(
    case_num == 43634107 & case_row == 1 ~ 90000003,
    case_num == 43634107 & case_row == 2 ~ 90000004, 
    case_num == 45202615 & case_row == 1 ~ 90000005,
    case_num == 45202615 & case_row == 2 ~ 90000006,
    TRUE ~ case_num
    )
  )

# Fixing case row numbers in those 2 case_numbers with case_row == 2
aps_2 <- aps_2 %>%
  mutate(case_row = case_when(
    case_num == 90000004 ~ 1L,
    case_num == 90000006 ~ 1L,
    TRUE ~ case_row
    )
  )
```


### Discrepancies in full name

Update name_full variable using the updated first and last names

```{r}
aps_2 <- aps_2 %>%
  mutate(name_full = paste(name_first, name_last, sep = " "))

# testing if there are any unfixed discrepancies
aps_2 %>%
  group_by(case_num) %>%
  mutate(test_name_full = all_match(name_full)) %>%
  filter(test_name_full == FALSE)
```


### Discrepancies in person id

```{r}
# View(discrepancies_person_id) # not fixed as we do not have information on this variable
```


### Discrepancies in street, city, and county

for all of these variables we are going to be using the value of the most frequently occurring instance


# Separate street addresses

Separate the street address into the number part and the street name part

```{r}
aps_2$county <- as.character(aps$county)
aps_2$city <- as.character(aps$city)
aps_2$street <- as.character(aps$street)

aps_2 <- aps_2 %>%
  group_by(case_num) %>%
  mutate(street = Mode(street),
  city = Mode(city),
  county = Mode(county))%>%
  ungroup()

aps_2 <- aps_2 %>%
  mutate(
    address_num         = stringr::str_extract(street, "^\\d{1,5}") %>% as.numeric(),
    address_street_name = stringr::str_trim(stringr::str_replace(street, "^\\d{1,5}", ""))
  )
```

Replaces spaces with underscores in address street name to compare with Medstar dataset during RecordLinkage

```{r}
aps_2 <- aps_2 %>%
  mutate(
    address_street_name = stringr::str_replace_all(address_street_name, "\\s", "_")
  )
```

### Discrepancies in age

```{r}
aps_2 <- aps_2 %>%
  group_by(case_num) %>%
  mutate(
    age = Mode(age))
```


### Discrepancies in dob

Replacing the individual elements (year, month, and day) of dob using the Mode()

```{r}
# Mode() for individual year, month, and day
aps_2 <- aps_2 %>%
  mutate(
    dob_year = format(dob, "%Y"),
    dob_month= format(dob, "%m"),
    dob_day = format(dob, "%d")) %>% 
  group_by(case_num) %>%
  mutate(
    dob_year = Mode(dob_year),
    dob_month = Mode(dob_month),
    dob_day = Mode(dob_day)) %>%
  mutate(dob = paste(c(dob_year), c(dob_month), c(dob_day), sep="-"),
         dob = as.Date(dob, format="%Y-%m-%d")) %>% 
  select(-c(dob_year, dob_month, dob_day))
```


* Fixing binary variables using max() if the variable has ever reported (value = 1) group by case_num

### Discrepancies in invalid_emotional_abuse  

```{r}
aps_2 <- aps_2 %>% 
  group_by(case_num) %>% 
  mutate(invalid_emotional_abuse = max(invalid_emotional_abuse),
         invalid_exploitation = max(invalid_exploitation),
         invalid_medical_neglect = max(invalid_medical_neglect),
         invalid_mental_health_neglect = max(invalid_mental_health_neglect),
         invalid_physical_abuse = max(invalid_physical_abuse),
         invalid_physical_neglect = max(invalid_physical_neglect),
         invalid_sexual_abuse = max(invalid_sexual_abuse),
         other_emotional_abuse = max(other_emotional_abuse),
         other_exploitation = max(other_exploitation),
         other_medical_neglect = max(other_medical_neglect),
         other_mental_health_neglect = max(other_mental_health_neglect),
         other_physical_abuse = max(other_physical_abuse),
         other_physical_neglect = max(other_physical_neglect),
         other_sexual_abuse = max(other_sexual_abuse),
         total_allegations_investigated = sum(total_allegations_investigated),
         total_other_dispositions = sum(total_other_dispositions),
         utd_emotional_abuse = max(utd_emotional_abuse),
         utd_exploitation = max(utd_exploitation),
         utd_medical_neglect = max(utd_medical_neglect),
         utd_mental_health_neglect = max(utd_mental_health_neglect),
         utd_physical_abuse = max(utd_physical_abuse),
         utd_physical_neglect = max(utd_physical_neglect),
         utd_sexual_abuse = max(utd_sexual_abuse),
         valid_emotional_abuse = max(valid_emotional_abuse),
         valid_exploitation = max(valid_exploitation),
         valid_medical_neglect = max(valid_medical_neglect),
         valid_mental_health_neglect = max(valid_mental_health_neglect),
         valid_physical_abuse = max(valid_physical_abuse),
         valid_physical_neglect = max(valid_physical_neglect),
         valid_sexual_abuse = max(valid_sexual_abuse))
```


### Discrepancies in zip

Fixing rules:
1. Reformat all zip codes to only include the first 5 digits because not all records' zip code was reported in the same format (some don't include the specific delivery route numbers (e.g., 75000-XXXX)
2. If the mode of is NA, then the zip will be manually filled in with available/earliest instance's zip

```{r}
aps_2$zip <- aps_2$zip %>% substr(1,5)

#creating new data frame for ease of writing code in next step
dz <- aps_2

aps_2 <- aps_2 %>% group_by(case_num) %>% 
  mutate(zip = Mode(zip)) %>% select(case_num,starts_with("zip"), everything()) %>% 
  mutate( 
    zip = case_when(
      case_num == 43517870 ~ dz$zip[dz$case_num == 43517870 & dz$case_row == 2], 
      case_num == 44161813 ~ dz$zip[dz$case_num == 44161813 & dz$case_row == 1], 
      case_num == 44446110 ~ dz$zip[dz$case_num == 44446110 & dz$case_row == 1], 
      case_num == 43598462 ~ dz$zip[dz$case_num == 43598462 & dz$case_row == 2], 
      case_num == 44261984 ~ dz$zip[dz$case_num == 44261984 & dz$case_row == 2], 
      case_num == 44339121 ~ dz$zip[dz$case_num == 44339121 & dz$case_row == 2], 
      case_num == 45285335 ~ dz$zip[dz$case_num == 45285335 & dz$case_row == 2], 
      case_num == 45431722 ~ dz$zip[dz$case_num == 45431722 & dz$case_row == 2],
      TRUE ~ zip
  ))
```


Remove all new variables/columns end with (.x/.y) created from all_match() function 

```{r}
aps_2 <- aps_2 %>% select(!ends_with(".y") & (!ends_with(".x")))
```

```{r}
rm(aps_test, dnf, dnl, dz, list=ls(pattern="^discrepancies_"))
```


# Create dummy variable for reporter

How many unique values are there for reporter? -- 14 different types

```{r}
unique(aps_2$reporter) 
```

Clean up the reporter names a little bit so that dummy columns are easier to read

```{r}
aps_2$reporter <- aps_2$reporter %>% 
  str_replace("health care providers/staff -- ems/emt", "ems") %>% # Shorten EMS
  str_replace_all(" |/|-", "_") %>% # Replaces spaces and special characters
  str_replace_all("_{2,}", "_") # Replace more than one underscore with a single underscore
```

Create dummy variables for reporter types

```{r}
aps_2 <- aps_2 %>% 
  fastDummies::dummy_cols(select_columns = "reporter")
```

```{r}
aps_2 <- aps_2 %>% 
  group_by(case_num) %>% 
  mutate(
    reporter_anonymous                               = max(reporter_anonymous),
    reporter_blank_unknown                           = max(reporter_blank_unknown),
    reporter_community_agencies_organizations        = max(reporter_community_agencies_organizations),
    reporter_ems                                     = max(reporter_ems),
    reporter_family_members_and_relatives            = max(reporter_family_members_and_relatives), 
    reporter_financial_institution                   = max(reporter_financial_institution), 
    reporter_friends_and_neighbors                   = max(reporter_friends_and_neighbors), 
    reporter_health_care_providers_staff             = max(reporter_health_care_providers_staff), 
    reporter_law_enforcement                         = max(reporter_law_enforcement), 
    reporter_legal_and_court_related_services_staff  = max(reporter_legal_and_court_related_services_staff), 
    reporter_other_providers                         = max(reporter_other_providers), 
    reporter_others                                  = max(reporter_others), 
    reporter_state_agencies                          = max(reporter_state_agencies), 
    reporter_victim                                  = max(reporter_victim)) %>% 
  ungroup()
```


# Create a total number of reporters variable

```{r}
aps_2 <- aps_2 %>% 
  rowwise() %>% 
  mutate(reporter_total = sum(reporter_anonymous + reporter_blank_unknown + 
                                reporter_community_agencies_organizations + reporter_ems + 
                                reporter_family_members_and_relatives + reporter_financial_institution + 
                                reporter_friends_and_neighbors + reporter_health_care_providers_staff + 
                                reporter_law_enforcement + reporter_legal_and_court_related_services_staff + 
                                reporter_other_providers + reporter_others + 
                                reporter_state_agencies + reporter_victim)) %>% 
  ungroup()
```

# Create min and max investigation date variables

```{r}
aps_2 <- aps_2 %>% 
  group_by(case_num) %>% 
  mutate(
    investigate_date_min = min(intake_date),
    investigate_date_max = max(intake_date)
  ) %>% ungroup()
```


3. If all discrepancies are fixed at this point, then reduce the data down to 1 row per case_num. 
```{r}
aps_unique <- aps_2 %>% filter(case_row == 1)
```



# MedStar service area

According to [MedStar's website](http://www.medstar911.org/service-area), the cities they serve include: Blue Mound, Burleson, Edgecliff Village, Forest Hill, Fort Worth, Haltom City, Haslet, Lakeside, Lake Worth, River Oaks, Saginaw, Sansom Park, Westover Hills, Westworth Village, White Settlement.

What cities appear in the data? -- Total of 254 different cities

```{r eval=FALSE}
aps_unique %>% 
  freqtables::freq_table(city)
```

There are a lot of cities included in this data that are outside of MedStar's service area. Create a dummy variable to indicate cities included in MedStar's coverage area.

```{r}
aps_unique <- aps_unique %>% 
  mutate(medstar_service_area = if_else(city %in% c(
    "blue mound", "burleson", "edgecliff village", "forest hill", "fort worth", 
    "haltom city", "haslet", "lake worth", "lakeside", "river oaks", "saginaw", 
    "sansom park", "westover hills", "westworth village", "white settlement"
    ), 1, 0, NA_real_
  ))
```

Note: There are no APS investigations with a city address of Edgecliff Village or Westover Hills.

```{r}
dim(aps_unique) # 15,283 observations and 68 variables
```

Add a little information about the area this data covers

What counties are represented in this data?

```{r echo=FALSE}
aps_unique %>% 
  mutate(
    `Medstar Service Area` = if_else(
      medstar_service_area == 0,
      "Outside MedStar's Service Area",
      "Inside MedStar's Service Area",
      NA_character_
    )
  ) %>% 
  group_by(`Medstar Service Area`) %>% 
  summarise(
    Counties = unique(county) %>% sort() %>% paste(collapse = ", ")
  )
```

How many cities are inside and outside of the MedStar Service Area? -- 13 inside and 241 outside. 

```{r echo=FALSE}
aps_unique %>% 
  mutate(
    `Medstar Service Area` = if_else(
      medstar_service_area == 0,
      "Outside MedStar's Service Area",
      "Inside MedStar's Service Area",
      NA_character_
    )
  ) %>% 
  group_by(`Medstar Service Area`) %>% 
  summarise(
    `Number of Cities` = unique(city) %>% length()
  )
```


# Create city_fw

```{r}
aps_unique <- aps_unique %>% 
  mutate(city_fw = if_else(city == "fort worth", 1, 0))
```

```{r}
dim(aps_unique) # 15,283    69
```


# Create DETECT identifier

Create a dummy variable corresponding to the dates when MedStar was using the DETECT tool.

```{r}
aps_unique <- aps_unique %>% 
  group_by(case_num) %>% 
  mutate(
    detect = case_when(
      as.Date(intake_date) >= "2015-09-17" & as.Date(intake_date) <= "2015-10-26" ~ 1, # 7,520 obs
      as.Date(intake_date) >= "2017-02-01"                                        ~ 1,
      TRUE                                                                        ~ 0
    )
  ) %>% ungroup()
```

Also, create a 4-level study period identifier

```{r}
aps_unique <- aps_unique %>% 
  mutate(
    study_period = case_when(
      as.Date(intake_date) < "2015-09-17" ~ 1,
      as.Date(intake_date) >= "2015-09-17" & as.Date(intake_date) <= "2015-10-26" ~ 2,
      as.Date(intake_date) >= "2015-10-27" & as.Date(intake_date) < "2017-02-01" ~ 3,
      as.Date(intake_date) >= "2017-02-01" ~ 4
    )
  )
```

```{r}
dim(aps_unique) # 15,283 observations and 71 variables
```


# Create study week variable

## Data time period

What time period does the APS data cover?

```{r echo=FALSE}
aps_unique %>% 
  summarise(
    `Earliest Date` = min(investigate_date_min),
    `Latest Date` = max(investigate_date_max)
  )
```

## Create a week number variable.

```{r}
aps_unique <- aps_unique %>% 
  mutate(
    intake_year = format(intake_date, "%y"),
    year_add = case_when(
      intake_year == "14" ~ (0 * 52),
      intake_year == "15" ~ (1 * 52),
      intake_year == "16" ~ (2 * 52),
      intake_year == "17" ~ (3 * 52),
      intake_year == "18" ~ (4 * 52)
    ),
    week = lubridate::week(intake_date),
    study_week = week + year_add,
    study_week = study_week - 52 # To make it base 1
  ) %>% 
  arrange(intake_date)
```

During which study weeks did DETECT screening occur?

```{r echo=FALSE}
aps_unique %>% 
  filter(detect == 1) %>% 
  pull(study_week) %>% 
  unique()
```

Drop unneeded variables

```{r}
aps_unique <- aps_unique %>% 
  select(-year_add, -week)
```

```{r}
dim(aps_unique) # 15,283 observations and 73 variables
```


# Valid/Invalid summary

Create a new variable that summarizes the results of APS investigations

It is possible for there to be more than one allegation associated with each APS investigation.

We want a single outcome per investigation/pcr combination in order to create a confusion matrix for each screening item.

To do that, we will create a new variable called "any_valid" that is equal to 1 if the disposition of _any_ allegation was valid, and 0 if the disposition of _all_ allegations were invalid.   
* If even one disposition is valid, then any valid equals 1   
* If all dispositions are invalid, then any valid equals 0   
* If all dispositions are other, then any valid equals NA
* If one disposition is other, and the rest are invalid, then any valid equals NA   

```{r}
aps_unique <- aps_unique %>%
  rowwise() %>% 
  mutate(
    total_valid   = sum(c_across(starts_with("valid"))),
    total_invalid = sum(c_across(starts_with("invalid"))),
    any_valid     = as.numeric(total_valid > 0),
    all_invalid   = as.numeric(total_valid == 0 & total_invalid > 0)
  ) %>% 
  ungroup()
```

Create 3-level summary variable

1. Any valid finding    
2. All invalid findings    
3. Unable to determine or other finding

```{r}
aps_unique <- aps_unique %>% 
  mutate(
    valid_3cat = case_when(
      any_valid == 1 ~ 1,
      all_invalid == 1 ~ 2,
      TRUE ~ 3
    )
  )
```

```{r}
dim(aps_unique) # 15,283 observations and 76 variables
```

# Check duplicate rows

For the all subsequent analyses, we are interested in changes in the number of individual "reports" of EA. Results are hidden to protect participant privacy.

```{r}
aps_unique %>% 
  group_by(intake_stage_num, reporter) %>% 
  filter(n() > 1)
```

So, there are 2 rows (1 report to APS) where a report was made to APS (intake stage number) by two people at the same time, but both individuals were the same type of reporter (both health care providers/staff). Catherine told me that it was possible for two people to call-in at the same time.


# Save data

```{r}
# readr::write_rds(aps_unique, "/Volumes/DETECT/one_year_data/aps_02_variable_management.rds")

# For Steph to save data and upload to kiteworks
readr::write_rds(aps_unique, "/Users/chiufengyap/OneDrive - The University of Texas Health Science Center at Houston/Research/MedStar_APS/delete/aps_02_variable_management.rds")
```

 
```{r}
# readr::write_csv(aps_unique, "/Volumes/DETECT/one_year_data/aps_02_variable_management.csv")

# For Steph to save data and upload to kiteworks
readr::write_csv(aps_unique, "/Users/chiufengyap/OneDrive - The University of Texas Health Science Center at Houston/Research/MedStar_APS/delete/aps_02_variable_management.csv")
```


# Session information

```{r echo=FALSE}
# rm(list = ls())
```

```{r echo=FALSE}
# sessionInfo()
```