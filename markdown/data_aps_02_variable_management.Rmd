---
title: "Manage Variables in APS Data"
date: "Created: 2019-01-25 <br> Updated: `r Sys.Date()`"
---

# ‚≠êÔ∏èOverview

* The raw APS data was imported in data_aps_01_import.Rmd

* In this file we do some basic data cleaning and prepare the data to be merged with MedStar data.


# üì¶Load packages

```{r message=FALSE}
library(dplyr)
library(purrr)
library(fastDummies)
library(stringr)
```


# üåêConnect to server

Connect to the UTHealth server.

```{bash eval=FALSE}
# For Brad
open 'smb://islgpcifs.uthouston.edu/sph_research/DETECT/one_year_data/'
```


# üì•Read-in data

* aps_01_import.rds was created in data_aps_01_import.Rmd

```{r}
aps <- readr::read_rds("/Volumes/one_year_data/aps_01_import.rds")
```

```{r}
dim(aps) # 18,080 observations and 47 variables
```


# Standardize character strings

Because we will merge this data with other data sets in the future based on character strings (e.g., name), we need to go ahead and standardize their formats here. This will prevent mismatches during the merges. Specifically, we:

1. Transform all characters to lower case   
2. Remove trailing spaces (e.g., "John Smith ")   
3. Remove double spaces (e.g., "John  Smith")

```{r}
aps <- aps %>% 
  mutate(
    across(
      .cols = where(is.character), 
      function(x) {
        x <- str_to_lower(x) # Make lowercase
        x <- str_trim(x) # Remove leading and trailing spaces
        x <- str_replace_all(x, "[[:blank:]]{2,}", " ") # Remove double spaces
      }
    )
  )
```

4. Remove any special characters (e.g., hyphens, periods)   

```{r}
aps <- aps %>% 
  mutate(
    across(
      c(name_last, name_first, name_full),
      ~ str_replace_all(.x, "[^a-zA-Z\\d\\s]", " ")
    )
  )
```

```{r}
dim(aps) # 18,080 observations and 47 variables
```


# Clean city

View current values for city

```{r eval=FALSE}
aps %>%
  freqtables::freq_table(city)
```

Need to move city value to street. Need to do so without using identifiers in the code. Therefore, adding a temporary row variable.

```{r}
aps <- aps %>% 
  mutate(row = row_number()) %>% 
  select(row, everything())
```

```{r}
aps <- aps %>% 
  mutate(
    street = if_else(row == 9868, city, street),
    city = if_else(row == 9868, NA_character_, city)
  )
```

Correct misspellings

```{r}
aps <- aps %>% 
  mutate(
    city = case_when(
      city == "cleburn" ~ "cleburne",
      city == "dalworthington garde" ~ "dalworthington garden",
      city == "ft worth" ~ "fort worth",
      city == "n richland hills" ~ "north richland hills",
      city == "unknown" ~ NA_character_,
      city == "wht settlemt" ~ "white settlement",
      TRUE ~ city
    )
  )
```

Drop row

```{r}
aps <- select(aps, -row)
```

```{r}
dim(aps) # 18,080 observations and 47 variables
```


# Resolve within-case discrepancies between rows

Which variables have differing values within case number? Each case number should be about the investigation of a single person. Therefore, most of the values for each variable within case should be constant. Unfortunately, this isn't the case. 

**Some notes from APS about administrative variables:**

* Each unique **Intake Stage #** (Column M) may be thought of as a unique report of ANE made on a particular date at a particular time. Each unique intake will generate a unique investigation, designated by an **Investigation Stage #** (Column L). So, each unique intake # is paired with an investigation #. With this a case is opened, assigned a **case #** (Column K)

* **Each row of data in this file may be best understood as a unique "reporter" which is the person making a report of abuse, neglect or exploitation (ANE) about a particular victim, on a particular date and time.** The name and DOB and address information in the first several columns are that of the victim, not the reporter. The only information provided about the reporter is column O, reporter type. 

* As already noted, each unique **Intake #** may be thought of as a unique report of ANE. However, there may be two reporters on the same intake, which appears as two rows with the same intake number. This reflects that two different people made the report at the same time, most likely in the way that one person speaks to the intake worker, then hands the phone to the other reporter. You may see a different reporter type in each row which is common when the victim is calling with a family member. Also common is the victim or a family member calling along with someone providing services or other assistance, maybe a health care provider, a community organization, or a law enforcement officer. They are making the call together, hence together they are making the report of ANE. Two people, one report. 

* In contrast to the above, you may see two rows with the same case number but different intake numbers which are on the same date. This represents two different reports called in independently by two different people. Thus, they have different intake numbers, and they are regarded as two different reports of the same abuse. And again, as mentioned above, they have the same case numbers because it was determined that after the initial report was made, the subsequent report concerned the same mistreatment or self-neglect and therefore was merged into the already-created case.

* For the ITS analysis, we are interested in changes in the number of individual "reports" of EA. So, each row should be a unique reporter/intake stage number combination.

* For the merge with the MedStar data, it's easiest if each case is collapsed into a single row. 

* Therefore, we after fixing discrepancies, we will create a long version and wide version of the APS data.

## Create case_row

To count the number of rows per case

```{r}
aps <- aps %>% 
  arrange(case_num) %>% 
  group_by(case_num) %>% 
  mutate(case_row = row_number()) %>% 
  ungroup() %>% 
  select(case_num, case_row, everything())
```

```{r}
dim(aps) # 18,080    48
```

## Descriptives

```{r}
aps %>% 
  summarise(
    Rows           = nrow(aps),
    `Unique cases` = length(unique(aps$case_num)),
    Difference     = Rows - `Unique cases`,
    `Min rows`     = min(case_row),
    `Max rows`     = max(case_row),
    .groups        = "drop"
  )
```

So, there are **18,080** total rows in the APS data. Of those, **15,280** represent unique cases (i.e., investigations). They do NOT represent unique people. We will identify unique people later. Most cases only have one row (i.e., one reporter); however, some cases have as many as 12 rows (i.e., 12 unique reporters, which is the person making a report of abuse, neglect or exploitation (ANE), about a particular victim, on a particular date and time).

The APS long data should have 18,080 rows. The APS wide data should have 15,280 rows.

## Check for discrepencies

### Helper function: all_match

```{r}
all_match <- function(x) {
  # If there are any NA's, check for all NA's
  if (any(is.na(x))) {
    # Check for all NA
    out <- all(is.na(x))
  } else {
    out <- length(unique(x)) == 1
  }
  out
}

# # For testing
# df <- tibble(
#   id = c(1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5),
#   x = c(1, 1, NA, NA, 3, NA, NA, 2, 3, NA, NA, NA),
#   y = rep("a", 12)
# )
# 
# df %>% 
#   group_by(id) %>% 
#   mutate(
#     x_match = all_match(x),
#     y_match = all_match(y)
#   )
```

```{r}
# It doesn't make sense to check columns that are different by design
inspect_cols <- aps %>% 
  select(
    -case_num, -case_row, -investigation_stage_num, -intake_stage_num, 
    -intake_date, -reporter, -investigation_closure_date, -closure_reason
  ) %>% 
  names()
```

```{r}
# Set column order ahead of time. This assumes that you know the names of each 
# of the columns you want to inspect
col_order <- map(
  names(aps), 
  function(x) {
    if (x %in% inspect_cols) {
      c(x, paste0(x, "_all_match"))
    } else {
      x
    }
  }
) %>% 
  unlist()
```

```{r}
inspect_aps <- aps %>% 
  group_by(case_num) %>% 
  mutate(
    across(
      .cols  = all_of(inspect_cols),
      .fns   = ~ all_match(.x),
      .names = "{col}_all_match"
    )
  ) %>% 
  dplyr::select(all_of(col_order)) %>% 
  ungroup()
```

Which columns have any discrepancies?

```{r}
inspect_aps %>% 
  select(ends_with("all_match")) %>% 
  select(where(~ !all(.x))) %>% 
  names()
```

Every column has at least one discrepancy. Let's view the discrepancies.

```{r}
all_match_cols <- select(inspect_aps, ends_with("all_match")) %>% 
  names() %>% 
  rlang::syms()
```

```{r}
walk(
  .x = all_match_cols,
  .f = function(x) {
    # Get column name w/o "all_matches" suffix
    no_suf <- str_remove(quo_name(x), "_all_match$")
    no_suf <- rlang::sym(no_suf)
    
    # Create name for new data frame
    df_nm <- str_replace(quo_name(x), "_all_match$", "")
    df_nm <- paste0("discrepancies_", df_nm)
    
    # Get the discrepancies
    results <- inspect_aps %>% 
      filter(!!x == FALSE) %>% 
      select(case_num, case_row, !!no_suf, !!x, everything())
    
    # Save to global environment
    assign(df_nm, results, envir = .GlobalEnv)
  }  
)
```


Left off here...

Need to resolve the discrepancies.

























# Separate dob's and street addresses

* We also separate dob into its component parts: month, day, year.

* We also separate the street address into the number part and the street name part

```{r}
aps <- aps %>%
  mutate(
    birth_mnth          = lubridate::month(dob),
    birth_day           = lubridate::day(dob),
    birth_year          = lubridate::year(dob),
    address_num         = stringr::str_extract(street, "^\\d{1,5}") %>% as.numeric(),
    address_street_name = stringr::str_trim(stringr::str_replace(street, "^\\d{1,5}", ""))
  )
```

```{r}
dim(aps) # 18,080 observations and 52 variables
```


# MedStar service area

According to [MedStar's website](http://www.medstar911.org/service-area), the cities they serve include: Blue Mound, Burleson, Edgecliff Village, Forest Hill, Fort Worth, Haltom City, Haslet, Lakeside, Lake Worth, River Oaks, Saginaw, Sansom Park, Westover Hills, Westworth Village, White Settlement.

What cities appear in the data?

```{r eval=FALSE}
aps %>% 
  freqtables::freq_table(city)
```

There are a lot of cities included in this data that our outside of MedStar's service area. Create a dummy variable to indicate cities included in MedStar's coverage area.

```{r}
aps <- aps %>% 
  mutate(medstar_service_area = if_else(city %in% c(
    "blue mound", "burleson", "edgecliff village", "forest hill", "fort worth", 
    "haltom city", "haslet", "lake worth", "lakeside", "river oaks", "saginaw", 
    "sansom park", "westover hills", "westworth village", "white settlement"
    ), 1, 0, NA_real_
  ))
```

Note: There are no APS investigations with a city address of Edgecliff Village or Westover Hills.

```{r}
dim(aps) # 18,080 observations and 53 variables
```

Add a little information about the area this data covers

What counties are represented in this data?

```{r echo=FALSE}
aps %>% 
  mutate(
    `Medstar Service Area` = if_else(
      medstar_service_area == 0,
      "Outside MedStar's Service Area",
      "Inside MedStar's Service Area",
      NA_character_
    )
  ) %>% 
  group_by(`Medstar Service Area`) %>% 
  summarise(
    Counties = unique(county) %>% sort() %>% paste(collapse = ", ")
  )
```

How many cities are inside and outside of the MedStar Service Area?

```{r echo=FALSE}
aps %>% 
  mutate(
    `Medstar Service Area` = if_else(
      medstar_service_area == 0,
      "Outside MedStar's Service Area",
      "Inside MedStar's Service Area",
      NA_character_
    )
  ) %>% 
  group_by(`Medstar Service Area`) %>% 
  summarise(
    `Number of Cities` = unique(city) %>% length()
  )
```


# Create city_fw

```{r}
aps <- aps %>% 
  mutate(city_fw = if_else(city == "fort worth", 1, 0))
```

```{r}
dim(aps) # 18,080    54
```


# Create DETECT identifier

Create a dummy variable corresponding to the dates when MedStar was using the DETECT tool.

```{r}
aps <- aps %>% 
  mutate(
    detect = case_when(
      as.Date(intake_date) >= "2015-09-17" & as.Date(intake_date) <= "2015-10-26" ~ 1,
      as.Date(intake_date) >= "2017-02-01"                                        ~ 1,
      TRUE                                                                        ~ 0
    )
  )
```

Also, create a 4-level study period identifier

```{r}
aps <- aps %>% 
  mutate(
    study_period = case_when(
      as.Date(intake_date) < "2015-09-17" ~ 1,
      as.Date(intake_date) >= "2015-09-17" & as.Date(intake_date) <= "2015-10-26" ~ 2,
      as.Date(intake_date) >= "2015-10-27" & as.Date(intake_date) < "2017-02-01" ~ 3,
      as.Date(intake_date) >= "2017-02-01" ~ 4
    )
  )
```

```{r}
dim(aps) # 18,080 observations and 56 variables
```


# Create study week variable

## Data time period

What time period does the APS data cover?

```{r echo=FALSE}
aps %>% 
  summarise(
    `Earliest Date` = min(intake_date),
    `Latest Date` = max(intake_date)
  )
```

## Create a week number variable.

```{r}
aps <- aps %>% 
  mutate(
    intake_year = format(intake_date, "%y"),
    year_add = case_when(
      intake_year == "14" ~ (0 * 52),
      intake_year == "15" ~ (1 * 52),
      intake_year == "16" ~ (2 * 52),
      intake_year == "17" ~ (3 * 52),
      intake_year == "18" ~ (4 * 52)
    ),
    week = lubridate::week(intake_date),
    study_week = week + year_add,
    study_week = study_week - 52 # To make it base 1
  ) %>% 
  arrange(intake_date)
```

```{r}
# Data checks
# aps_its %>% select(intake_date, intake_year, year_add, week, study_week, detect)
```

During which study weeks did DETECT screening occur?

```{r echo=FALSE}
aps %>% 
  filter(detect == 1) %>% 
  # For data checking
  # select(intake_date, study_week)
  pull(study_week) %>% 
  unique()
```

Drop unneeded variables

```{r}
aps <- aps %>% 
  select(-year_add, -week)
```

```{r}
dim(aps) # 18,080 observations and 58 variables
```


# Create dummy variable for reporter

How many unique values are there for reporter?

```{r}
unique(aps$reporter)
```

Clean up the reporter names a little bit so that dummy columns are easier to read

```{r}
aps$reporter <- aps$reporter %>% 
  str_replace("health care providers/staff -- ems/emt", "ems") %>% # Shorten EMS
  str_replace_all(" |/|-", "_") %>% # Replaces spaces and special characters
  str_replace_all("_{2,}", "_") # Replace more than one underscore with a single underscore
```

Create dummy variables

```{r}
aps <- aps %>% 
  dummy_cols(select_columns = "reporter")
```

```{r}
dim(aps) # 18,080 observations and 59 variables
```





# Create min and max investigation date variables


# Create a number of reporters variable


# Valid/Invalid summary

Create a new variable that summarizes the results of APS investigations

It is possible for there to be more than one allegation associated with each APS investigation.

We want a single outcome per investigation/pcr combination in order to create a confusion matrix for each screening item.

To do that, we will create a new variable called "any_valid" that is equal to 1 if the disposition of _any_ allegation was valid, and 0 if the disposition of _all_ allegations were invalid.   
* If even one disposition is valid, then any valid equals 1   
* If all dispositions are invalid, then any valid equals 0   
* If all dispositions are other, then any valid equals NA
* If one disposition is other, and the rest are invalid, then any valid equals NA   

```{r}
aps <- aps %>% 
  mutate(
    total_valid   = select(., starts_with("valid")) %>% rowSums(),
    total_invalid = select(., starts_with("invalid")) %>% rowSums(),
    any_valid     = as.numeric(total_valid > 0),
    all_invalid   = as.numeric(total_valid == 0 & total_invalid > 0)
  )
```

Create 3-level summary variable

1. Any valid finding    
2. All invalid findings    
3. Unable to determine or other finding

```{r}
aps <- aps %>% 
  mutate(
    valid_3cat = case_when(
      any_valid == 1 ~ 1,
      all_invalid == 1 ~ 2,
      TRUE ~ 3
    )
  )
```

```{r}
# Data checks
# check <- aps %>% 
#   select(closure_reason:total_other_dispositions, total_valid:valid_3cat)
```

```{r}
dim(aps) # 18,080 observations and 64 variables
```


# Check duplicate rows

For the all subsequent analyses, we are interested in changes in the number of individual "reports" of EA. So, each row should be a unique reporter/intake stage number combination. Results are hidden to protect participant privacy.

```{r eval=FALSE}
aps %>% 
  group_by(intake_stage_num, reporter) %>% 
  filter(n() > 1)
```

So, there are 10 rows (5 reports to APS) where a report was made to APS (intake stage number) by two people at the same time, but both individuals were the same type of reporter (both health care providers/staff or both family members and relatives). Catherine told me that it was possible for two people to call-in at the same time.


# Save data

```{r}
readr::write_rds(aps, "/Volumes/DETECT/one_year_data/aps_02_variable_management.rds")
```


```{r}
readr::write_csv(aps, "/Volumes/DETECT/one_year_data/aps_02_variable_management.csv")
```


# Session information

```{r echo=FALSE}
rm(list = ls())
```

```{r echo=FALSE}
sessionInfo()
```