---
title: "Linking MedStar and APS IDs"
format: html
editor: visual
---

# Summary

Summary will go here

# Imports

test## Library Imports

```{r}
#| message: false
#| warning: false

library(tidyverse)
library(here)
library(fastLink)
```

## Data Imports

The MedStar data set was loaded for processing.

```{r}
medstar <- readRDS(here("data","DETECT Shared GRAs","medstar_cleaning",
                             "medstar_01.rds"))
```

The APS data set was loaded for processing.

```{r}
aps <- readRDS(here("data","DETECT Shared GRAs","aps_cleaning",
                             "aps_01.rds"))
```

## Functions

### Unique Value Summary

A function written in a previous cleaning document was imported. It was written to display counts of each unique observations within a selection of columns.

```{r}
get_unique_value_summary <- function(df,cols){
  
  # Input: 
  #     df (data frame) - original source data frame
  #     cols (list) - list of target column names as strings
  # Output:
  #     unique_summary (data frame) - summary counts of each unique value in
  #           each of the target columns
  
  # Get list of unique values in all target columns
  
  val <- unique(as.factor(as.vector(as.matrix(df[cols]))))
  
  # Initialize output data frame with unique value row
  
  unique_summary <- data.frame("value"=val)
  
  # Get counts of unique values in original data frame
  
  for (i in cols){
    
    # utilizes table to get summary count of each column
    
    table <- as.data.frame(table(df[i]))
    
    # sets column names to "value" and "freq"
    
  colnames(table) <- c("value","freq")
  
    # adds count of missing values in each column
  
  table<- add_row(table, value = NA, freq = sum(is.na(df[i])))
  
    # readjusts names of columns to "value" and the name of the target column
  
  colnames(table) <- c("value",i)
  
    # joins table's summary counts to complete the count values
  
    unique_summary <- left_join(unique_summary,table, by="value")
  }
  
  # returns completed, but unordered, data frame
  
  unique_summary
  }
```

### Match Check

A function was written to modify the fastLink::getMatches output to facilitate immediate pairwise comparison of identifiers in a fastLink match pair. This function was based on the original function written by Dr. Cannell to view stacked pairs when fastLink had been used to match observations within a single data set.

```{r}
get_pair_data <- function(dfA_pack, dfB_pack, match_vars, fastlink_out){
  #
  # Uses fastlink::getMatches to get matched pairs from dfA and dfB
  # Takes data from dfA and dfB to allow comparison of matches based on
  # the variables utilized for fastLink matching
  #
  #
  # Inputs:
  #     dfA_pack: $df = dataframe A
  #               $ids = identifiers for dfA, with row-unique ID first
  #               $prefix = a prefix to specifiy a column came from dfA
  #     dfB_pack: $df = dataframe B
  #               $ids = identifiers for dfB, with row-unique ID first
  #               $prefix = a prefix to specifiy a column came from dfB
  #     match_vars: list of variables used in fastLink matching
  #     fastlink_out: fastlink object, output from fastLink matching
  #
  # Returns:
  #     pair_data: dataframe where each row represents a fastLink match,
  #                 outlines posterior probability, identifiers, contents
  #                 of each match variable for side-by-side comparison, and
  #                 gamma of the variable comparison
  
  
  # Unpack all dfA values for stack creation
  dfA <- dfA_pack$df
  dfA_ids <- dfA_pack$ids
  dfA_vars <- c()
  for (var in match_vars){
      dfA_vars <- c(dfA_vars, paste(dfA_pack$prefix,var, sep="_"))
    }
  
  # Unpack all dfB values for stack creation  
  dfB <- dfB_pack$df
  dfB_ids <- dfB_pack$ids
  dfB_vars <- c()
  for (var in match_vars){
      dfB_vars <- c(dfB_vars, paste(dfB_pack$prefix,var, sep="_"))
    }

  # Get match data using fastLink & fastLink output
  matches <- getMatches(dfA, dfB, fl.out = fastlink_out)
  
  # Subset only desired data from matches
  match_data_vars <- matches %>%
    select(posterior, all_of(dfA_ids), all_of(dfB_ids),
           all_of(starts_with("gamma"))
           ) %>%
    names()
  
  pair_data <- subset(matches, select = match_data_vars)
  
  # Initialize output data frame column names with posteriors, IDs, and gammas
  
  col_order <- pair_data %>%
    select(posterior, all_of(dfA_ids), all_of(dfB_ids)
      ) %>%
    names()
  
  # Iteratively match and build output data frame
  
  for (i in 1:length(match_vars)){
  
    # Match dfA variable data for each match
    dfA_cols <- subset(dfA, select = c(dfA_ids[1], match_vars[i]))
    names(dfA_cols)[2] <- dfA_vars[i]
    pair_data <- left_join(pair_data, dfA_cols, by=dfA_ids[1], relationship = "many-to-one")
  
    # Match dfB variable data for each match
    dfB_cols <- subset(dfB, select = c(dfB_ids[1], match_vars[i]))
    names(dfB_cols)[2] <- dfB_vars[i]
    pair_data <- left_join(pair_data, dfB_cols, by=dfB_ids[1], relationship = "many-to-one")
    
    # Update list of column names
    
    col_order <- c(col_order, dfA_vars[i], dfB_vars[i], paste("gamma",i,sep="."))
                   
  }
  
  # Reorder output columns
  pair_data <- pair_data[,col_order]
  
  # Return output
  pair_data

}
```

### Subject ID Creation

A function was written to add a unique group ID based on fastLink pair match data. This function was based on the original function written by Dr. Cannell to add a unique subject ID when fastLink had been used to match observations within a single data set.

```{r}
stack_ids <- function(dfA_pack, dfB_pack, fastlink_obj, paired_matches){
  #
  # Takes match data from fastLink object and pair-comparison tibble created
  # using get_pair_data() to add a unique group ID to the paired match data
  #
  # Inputs:
  #     dfA_pack: $df = dataframe A
  #               $ids = identifiers for dfA, with row-unique ID first
  #               $prefix = a prefix to specifiy a column came from dfA
  #     dfB_pack: $df = dataframe B
  #               $ids = identifiers for dfB, with row-unique ID first
  #               $prefix = a prefix to specifiy a column came from dfB
  #     fastlink_obj: fastlink object, output from fastLink matching
  #     paired_matches: tibble, output from get_pair_data()
  #
  # Returns:
  #     out:      Modified paired_matches which includes a unique group ID
  
  
  # Turn fastLink results into tibble of rows and their matches
  matches <- tibble::tibble(
    dfA_row = fastLink_obj$matches$inds.a,
    dfB_row = fastLink_obj$matches$inds.b
  )
  
  # Nest all matches for each row
  matches <- matches %>% 
    dplyr::group_by(dfB_row) %>% 
    dplyr::mutate(matches = list(dfA_row)) %>%
    dplyr::ungroup()
  
  # Reduce to unique sets of matching rows
  # i.e. 1,2,3 is the same as 3,2,1
  matches <- matches %>% 
    dplyr::mutate(dfA_matches = purrr::map_chr(
      matches,
      function(x) {
        x = sort(x) # 1,2,3 is the same as 3,2,1
        x = paste(x, collapse = ",") # Convert list to character string
        x
      })
    ) %>% 
    dplyr::select(dfA_matches) %>%
    distinct() # Reduce to 1 row per group of matches
  
  
  # Sequentially number each group of matches
  # This will become the unique id
  matches <- matches %>%
    dplyr::mutate(
      id = row_number(),
      dfA_row = purrr::map( # Turn back into list
        dfA_matches,
        ~ scan(text = ., what = 0L, sep = ",", quiet = TRUE)
      )
    ) 
  
  # Covert to data frame with the appropriate id number for each
  # unique observation id in dfA
  
  matches <- matches %>%
    tidyr::unnest(cols=c(dfA_row)) %>% 
    dplyr::select(id, dfA_row) %>%
    dplyr::left_join( 
    dfA_pack$df[,dfA_pack$ids[1]] %>%
      dplyr::mutate(dfA_row = row_number()), 
    by="dfA_row"
    ) %>%
    dplyr::select(id, dfA_pack$ids[1])
  
  # Join the unique ID into the paired matches set for review, based on
  # the dfA unique observation ID
  
  out <- matches %>%
    dplyr::right_join(
      paired_matches,
      by = dfA_pack$ids[1]
    )
  
  # Return revised paired matches with pair ID
  out
}
```


# Preparing Datasets for Match

## Variable Selection

Our data sets contained many more variables than we required for matching. To reduce the memory burden of the match process, both data sets had their variables reduced to those necessary for performing the match, verifying matches in previously matched groups, and adding the new group ID into the original data sets.

The 13 identifiers common to both data sets would be utilized:

  -   Name: `pt_name_full`, `pt_name_first`, `pt_name_last`
  -   Date of Birth: `pt_dob`, `pt_dob_year`, `pt_dob_month`, `pt_dob_day`
  -   Address: `pt_address_num`, `pt_address_street`, `pt_address_unit`, `pt_address_city`, `pt_address_zip`, `pt_address_pobox` 

```{r}
identifiers <- aps %>%
  select(pt_name_full, pt_name_first, pt_name_last, 
         pt_dob, pt_dob_year, pt_dob_month, pt_dob_day, 
         pt_address_num, pt_address_street, pt_address_unit, pt_address_city, 
         pt_address_zip, pt_address_pobox) %>%
  names()
```

The record ID from the source data, and the unique subject ID, were also selected from each data set.

```{r}
aps_vars <- aps %>%
  select(aps_row, aps_person_id) %>%
  names()

medstar_vars <- medstar %>%
  select(ms_epcr_row, ms_id) %>%
  names()
```

We reduced our data sets to only include these variables.

```{r}
aps <- aps %>%
  subset(select = c(aps_vars, identifiers))

medstar <- medstar %>%
  subset(select = c(medstar_vars, identifiers))
```

## Row Reduction to only Unique Combinations

The MedStar data set contained 28,228 observations, while the APS data set contained 18,152 observations.

```{r}
nrow(medstar)
nrow(aps)
```

To reduce the memory burden of matching, we reduced our data sets into only unique combinations of the unique subject id and all identifiers.

### MedStar Reduction

There were 16,578 unique MedStar Subject IDs in the MedStar data set.

```{r}
length(unique(medstar$ms_id))
```

By reducing only to unique combinations of identifiers in each MedStar Subject ID, we were able to reduce our search space to 20,100 observations (28.79% reduction) without loss of any MedStar Subject ID.

```{r}
reducing_vars <- medstar %>%
  select(all_of(identifiers), ms_id) %>%
  names()

medstar <- medstar %>%
  group_by(ms_id) %>%
  distinct(pick(all_of(reducing_vars)), .keep_all = TRUE) %>%
  ungroup()

nrow(medstar)
length(unique(medstar$ms_id))
```

### APS Reduction

There were 11,178 unique APS Person IDs in the APS data set.

```{r}
length(unique(aps$aps_person_id))
```

By reducing only to unique combinations of identifiers in each APS Person ID, we were able to reduce our search space to 12,676 observations (30.17% reduction) without the loss of any APS Person ID.

```{r}
reducing_vars <- aps %>%
  select(all_of(identifiers), aps_person_id) %>%
  names()

aps <- aps %>%
  group_by(aps_person_id) %>%
  distinct(pick(all_of(reducing_vars)), .keep_all = TRUE) %>%
  ungroup()

nrow(aps)
length(unique(aps$aps_person_id))
```
## Conversion of Patient ZIP Code to Numeric

Patient Zip code data, in `pt_address_zip` for both data sets, was coded as character to preserve leading zeros and formatting. For the purposes of numeric matching with fastLink, it was converted to a numeric in both data sets.

```{r}
medstar$pt_address_zip <- as.numeric(medstar$pt_address_zip)
aps$pt_address_zip <- as.numeric(aps$pt_address_zip)
```

## Conversion from Integer to Numeric in APS Data

Date of Birth fields were stored as integers in the APS data, which was not considered a numeric by fastLink. These variables were converted for fastLink compatibility.

```{r}
aps$pt_dob_month <- as.numeric(aps$pt_dob_month)
aps$pt_dob_year <- as.numeric(aps$pt_dob_year)
aps$pt_dob_day <- as.numeric(aps$pt_dob_day)
```

## Packing of Source Data Frames for Match Checking

We packed our variables for use with the `get_pair_data()` function.

```{r}
dfA_pack <- list()
dfA_pack$df <- medstar
dfA_pack$ids <- c("ms_epcr_row", "ms_id")
dfA_pack$prefix <- "ms"

dfB_pack <- list()
dfB_pack$df <- aps
dfB_pack$ids <- c("aps_row", "aps_person_id")
dfB_pack$prefix <- "aps"
```


# Determination of Variables for Matching

## Initial Attempt

Initial attempts to link records matched based on 9 identifying variables: Patient Name (First and Last), Patient DOB (Year, Month, and Day), and Patient Address (Street Number, Street Name, City, and Zip).


```{r}
## Defining Target Variables
str_vars <- c("pt_name_first","pt_name_last","pt_address_street","pt_address_num","pt_address_city")
num_vars <- c("pt_dob_month","pt_dob_day","pt_dob_year")

match_vars <- c(str_vars, num_vars)

## fastLink
fl_out <- fastLink(
  dfA = dfA_pack$df, 
  dfB = dfB_pack$df,
  varnames = match_vars,
  stringdist.match = str_vars,
  numeric.match = num_vars,
  dedupe.matches = FALSE,
  verbose = TRUE
  )
```

We used the fastLink output to inspect our matches.

```{r}
checking_stack <- get_pair_data(dfA_pack, dfB_pack, match_vars, fl_out)
checking_ids <- stack_ids(dfA_pack, dfB_pack, fl_out, checking_stack)
```


### Output Summary

This processing produced 9,531 pairs; when pairs were processed to add group IDs, the presence of multiple-match pairs resulted in 27,835 pairs across 2,639 group IDs.


```{r}
nrow(checking_stack)

nrow(checking_ids)
length(unique(checking_ids$id))
```

Posterior probabilities ranged from 0.8546268886898 to 0.9999999999280. No entries had posterior probabilities of 1.0, which would have indicated a perfect match.

```{r}
sum(is.na(checking_ids$posterior))

sum(checking_stack$posterior == 1)

summary(checking_stack$posterior)
```

Cursory examination revealed a very large number of mismatches due to similarities in birth date or address, but vastly different names.


### Duplicate Checking

We found there were 1,881 APS Row Numbers repeated across 1,590 Group IDs and 26,520 observations. There were no pairs missing an APS Row Number

```{r}
duplicates_aps <- checking_ids %>%
  filter((duplicated(aps_row) | duplicated(aps_row, fromLast=TRUE)))

length(unique(duplicates_aps$aps_row))
length(unique(duplicates_aps$id))
nrow(duplicates_aps)

sum(is.na(duplicates_aps$aps_row))

nrow(duplicates_aps) == length(unique(duplicates_aps$aps_row))
```

We found there were 2,147 MedStar ePCR Row Numbers repeated across 1,399 Group IDs and 25,258 observations. There were no pairs missing an MedStar ePCR Row Number.

```{r}
duplicates_ms <- checking_ids %>%
  filter((duplicated(ms_epcr_row) | duplicated(ms_epcr_row, fromLast=TRUE)))

length(unique(duplicates_ms$ms_epcr_row))
length(unique(duplicates_ms$id))
nrow(duplicates_ms)

sum(is.na(duplicates_ms$ms_epcr_row))

nrow(duplicates_ms) == length(unique(duplicates_ms$ms_epcr_row))
```

We flagged all observations with a matching `aps_row` or `id` from the duplicated observations for a manual review. We similarly flagged all observations with a matching `ms_epcr_row` from the duplicated observations, and observations which flagged for both.

All 26,520 observations flagged for duplicate APS Row Number values were also flagged for duplicate MedStar ePCR Row Number values.  

```{r}
checking_ids$flag_aps <- FALSE
checking_ids$flag_ms <- FALSE
checking_ids$flag_both <- FALSE

checking_ids <- checking_ids %>%
  mutate(flag_aps = case_when(id %in% duplicates_aps$id ~ TRUE,
                          aps_row %in% duplicates_aps$aps_row ~ TRUE,
                          TRUE ~ flag_aps)
         ) %>%
  mutate(flag_ms = case_when(id %in% duplicates_ms$id ~ TRUE,
                          ms_epcr_row %in% duplicates_ms$ms_epcr_row ~ TRUE,
                          TRUE ~ flag_aps)
         ) %>%
  mutate(flag_both = ifelse((flag_aps & flag_ms), TRUE, flag_aps)
         )

get_unique_value_summary(checking_ids,c("flag_aps","flag_ms","flag_both"))
```

Only 1,315 pairs (4.72%) in 1049 groups (39.75%) were not duplicated.

```{r}
nondup_ids <- checking_ids %>% 
  filter(!flag_both) %>% 
  select(id)

length(unique(nondup_ids$id))
```


In checking these values, we saw that many of them appeared to be caused by a prodigious number of false matches, similar to the cursory examination.

```{r}
checking <- filter(checking_ids, (flag_aps | flag_ms | flag_both))
```


# Bottom Placeholder
